<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>

<style>
    .btn-square {
      display: inline-block;
      padding: 0.5em 0.5em;
      text-decoration: none;
      background: #668ad8;
      color: #FFF;
      border-bottom: solid 4px #626295;
      border-radius: 5px;
    }

    .btn-square:active {
      -webkit-transform: translateY(4px);
      transform: translateY(4px);
      border-bottom: none;
    }
  .markdown-body {
    box-sizing: border-box;
    min-width: 200px;
    max-width: 980px;
    margin: 0 auto;
    padding: 45px;
  }
  p.caption{
    display:none;
  }
  img {width: 100%}

  @media (max-width: 767px) {
    .markdown-body {
      padding: 15px;
    }
  }
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://kaityo256.github.io/python_zero/github-markdown.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
</head>
<body>
<article class="markdown-body">
<h1 id="動的計画法"><a href="https://kaityo256.github.io/python_zero/dp/">動的計画法</a></h1>
<p><a href="../index.html">[Up]</a> <a href="https://github.com/kaityo256/python_zero">[Repository]</a></p>
<h2 id="本講で学ぶこと">本講で学ぶこと</h2>
<ul>
<li>組み合わせ最適化問題</li>
<li>貪欲法</li>
<li>全探索</li>
<li>メモ化再帰による動的計画法</li>
<li>余談：人外について</li>
</ul>
<h2 id="最適化問題">最適化問題</h2>
<div class="figure">
<img src="fig/tasklist1.png" alt="日常における最適化問題" />
<p class="caption">日常における最適化問題</p>
</div>
<p>いま、あなたは以下の三つのタスクをこなす必要があるとしよう。</p>
<ul>
<li>スーパーで食材の買い物をする</li>
<li>郵便局で封筒を簡易書留で出す</li>
<li>借りていた本を図書館に返しに行く</li>
</ul>
<p>実行順序は自由だ。どうせならなるべく楽にすべてのタスクをこなしたい。簡単のため、スーパー、図書館、郵便局は家から等距離にあるとしよう。どのような順番でタスクをこなすべきだろうか？</p>
<div class="figure">
<img src="fig/tasklist2.png" alt="タスクの実行順序" />
<p class="caption">タスクの実行順序</p>
</div>
<p>もし「スーパー」「郵便局」「図書館」という順序でタスクをこなすと、あなたは「重い本を持ちながらスーパーで買い物をして」「スーパーで購入した食材と本を持ちながら郵便局に行き」「最後に本を返す」ということになり、手が疲れてしまう。この場合は「図書館」「郵便局」「スーパー」の順番が良いだろう。まずは重い本をなんとかし、荷物が軽い状態で郵便局のタスクをこなし、最後に食材を買って帰れば、疲れは最小限で済む。</p>
<p>このように、我々は日常的に「何かの条件を満たしつつ、何かを最適化する」という問題に直面しており、「要領の良い人」は、普段からこのような最適化問題を無意識に解いている。しかし、これらの問題の多くは「最適解」を得ることが難しい「NP困難 (NP-hard)」な問題であることが多い。「NP困難」については深く立ち入らないが、ようするに「最適解を得るには全ての組み合わせを調べるしかなく、要素数が増えると計算時間が爆発してしまう」という問題のことである。このような問題は、応用上は必ずしも厳密解を得る必要はなく、近似解が求まればそれで十分な場合も多いため、高速に近似解を求める手法も数多く提案されている。しかし、ある種の組み合わせ問題は効率的に解くことができる。その際に使われる手法が本講で紹介する「動的計画法」である。</p>
<h2 id="ナップサック問題">ナップサック問題</h2>
<div class="figure">
<img src="fig/knapsack.png" alt="ナップサック問題" />
<p class="caption">ナップサック問題</p>
</div>
<p>これまで、どこかで「ナップサック問題」という言葉は聞いたことがあるだろう。例えばこんな問題である。あなたは洞窟の奥で見事宝物庫を見つけた。そこには重さと価値がまちまちな「宝物」が４つあった。</p>
<p>それぞれの重さと価値が以下のように与えられているとしよう。</p>
<ul>
<li>金の延べ棒: 重さ 5、価値 50</li>
<li>トロフィー: 重さ 4、価値 36</li>
<li>カップ: 重さ 3、価値 24</li>
<li>コイン: 重さ 3、価値 33</li>
</ul>
<p>あなたは重さの合計「10」までしか持ち歩くことができないので、全てを持ち帰ることはできない。ではどの品物を持ち帰れるのが一番「得」であろうか？</p>
<p>このように「たくさんの物のセットが与えられ、何かの条件(ここでは重さの総和)を満たしつつ、何かの価値を最大化するような組み合わせを探す」という問題は、「組み合わせ最適化問題」と呼ばれる。ナップサック問題は典型的な組み合わせ最適化問題の一つである。</p>
<p>あまり意識していないかもしれないが、我々は日常的に組み合わせ最適化問題を解いている。例えばレストランでメニューを見ながら何を食べるか決める時、当然ながら美味しいものを食べたいと思うことであろう。しかし、美味しい物は一般に値段もカロリーも高いというのがこの世の摂理である。そこで、「ある程度の予算、カロリーの制限内で、一番幸せ度が高いメニューの組み合わせ」を探すことになる。これは典型的なナップサック問題である。</p>
<h2 id="貪欲法">貪欲法</h2>
<p>さて、動的計画法を考える前に、近似解を求める方法を紹介しよう。組み合わせ最適化の近似解を求める方法はたくさんあるが、その中でも一番簡単な「貪欲法(Greedy Method)」を紹介する。</p>
<p>ナップサック問題において、ある重さ以内で最大の価値を得たいのだから、理想的には最大の重さまで詰めて、かつ価値を最大化したい。したがって、一つ一つの品物についても、「重さあたりの価値」が高いものを選びたくなるであろう。そこで、「重さあたりの価値」について高い順に並べて、上から順番に選んで行く、というアルゴリズムが考えられる。これが貪欲法である。</p>
<p>先程の「宝物」の問題を考えて見よう。それぞれについて「重さあたりの価値」を計算し、それが高い順に並べてみる。</p>
<ul>
<li>コイン: 重さ 3、価値 33、重さあたりの価値 11</li>
<li>金の延べ棒: 重さ 5、価値 50、重さあたりの価値 10</li>
<li>トロフィー: 重さ 4、価値 36、重さあたりの価値 9</li>
<li>カップ: 重さ 3、価値 24、重さあたりの価値 8</li>
</ul>
<p>「得られたリストを上から順番に持てるだけ持つ」のが貪欲法である。この場合は、まずコインを選び、次に金の延べ棒を選んだ時点で重さが「8」となるため、もう他の品物を選ぶことはできない。貪欲法による結果は「重さ8、価値83」となった。実際には「コイン、トロフィー、カップ」の組み合わせで「重さ10、価値93」が最適解であるため、それには及ばない。</p>
<div class="figure">
<img src="fig/greedy.png" alt="貪欲法" />
<p class="caption">貪欲法</p>
</div>
<p>しかし、一般的に貪欲法は(よほど狙ってそう問題を作らない限り)わりと良い近似解を与えることが多く、問題によっては最適解を与えることもある(ダイクストラ法など)。「とにかく選ぶべきものに評価値を与え、一番良いものから順番に選び、制約に達したらやめる」という簡単なアルゴリズムであり、汎用性もあることから、覚えておいて損はないアルゴリズムである。</p>
<h2 id="全探索">全探索</h2>
<p>「全探索」とは、その名の通りすべての可能性を列挙してしまう方法である。組み合わせ最適化問題について全探索すれば、当然のことながら最適解が得られるが、探索すべき組み合わせが問題サイズに対して急激に(指数関数的に)大きくなるため、ある程度以上大きな問題には適さない。しかし、全探索はすべての探索アルゴリズムの基本であるので、ここで簡単に触れておきたい。</p>
<p>先程の「宝物」の問題では、重さと価値が以下のように与えられてた。</p>
<ul>
<li>金の延べ棒: 重さ 5、価値 50</li>
<li>トロフィー: 重さ 4、価値 36</li>
<li>カップ: 重さ 3、価値 24</li>
<li>コイン: 重さ 3、価値 33</li>
</ul>
<p>これを、上から順番に「選ぶ」「選ばない」の二択で探していく。</p>
<div class="figure">
<img src="fig/fullsearch.png" alt="全探索" />
<p class="caption">全探索</p>
</div>
<p>上図ではスペースの関係から3種類、8通りしか示していないが、基本的に<span class="math inline">\(N\)</span>個の品物があれば、それぞれについて選ぶ、選ばないの二通りがあるため、<span class="math inline">\(2^N\)</span>通りの選び方がある。なお、途中で「重さオーバー」した場合はそれ以上探索はしない。</p>
<p>前述の通り、全探索アルゴリズムは問題サイズに対して指数関数的に計算量が増えていくため、実用には適さない。しかし、全探索はすべてのアルゴリズムの基本であり、かつ要素数が数十個くらいまでであれば全探索の守備範囲となる。例えば<span class="math inline">\(N=30\)</span>でも<span class="math inline">\(2^{30} \sim 1.1 \times 10^9\)</span>であり、最近の計算機ならまだ余裕である。再帰を使った全探索コードは短く、たまに便利なので、これもすぐに組めるようになっておきたい。</p>
<h2 id="動的計画法とは">動的計画法とは</h2>
<p>さて、「貪欲法」は簡単だが近似解しか得られず、「全探索」は厳密だが探索時間がかかりすぎる。ここでは「厳密」で、かつ「効率的」に解を得られる <strong>動的計画法 (Dynamic Programming, DP)</strong> について説明しよう。「動的計画法」という、難しそうな名前がついているが、そのアルゴリズムの骨子はさして難しくない。動的計画法が適用できる条件は、以下の二つである。</p>
<ul>
<li>大きな問題を、より小さな問題に分解できること (分割統治)</li>
<li>分解された小さな問題の結果が、再利用可能であること (メモ化)</li>
</ul>
<p>ナップサック問題でも動的計画法の説明はできるが、より説明がわかりやすい「最適経路探索問題」を例に動的計画法の説明をする。</p>
<p>あなたは旅行を計画している。目的値に到着するのに、複数の経路があるのだが、できるだけ早く、もしくはできるだけ安く到着したい。どのような経路を取ればよいだろうか？いま、この経路をグラフで表現すると以下のようになるとする。</p>
<div class="figure">
<img src="fig/shortestpath1.png" alt="最短経路問題" />
<p class="caption">最短経路問題</p>
</div>
<p>あたたはA地点からI地点までいきたい。そのための経由地(例えば電車の駅だと思えばよい)がBからHまである。それぞれの地点間にはコストが定義されている。この場合のコストは時間もしくは料金である。</p>
<p>先程の最短経路探索問題の回答は、以下のようなものだ。</p>
<div class="figure">
<img src="fig/shortestpath2.png" alt="最短経路" />
<p class="caption">最短経路</p>
</div>
<p>A→B→E→C→F→H→I</p>
<p>この時、最短経路は13になる。さて、この経路をよく見てみよう。いま、最短経路がこのように定まったとしよう。AからEを経由してIに到達している。この時、「AからE」への経路も最短であり、「EからI」への経路も最短となっている。</p>
<div class="figure">
<img src="fig/shortestpath3.png" alt="部分経路の最短性" />
<p class="caption">部分経路の最短性</p>
</div>
<p>このように、最短経路問題は「もし最短経路が求まったのなら、その途中の任意の二点間の経路も最短である」という性質をもっている。もしこの性質が満たされていないとしよう。例えば上記では、「AからE」の最短経路のコストは3であり、「EからI」の最短経路のコストは10、あわせて「AからI」へのコストは13となっている。もし「AからE」に、コスト2以下のパスがあるならば、そちらを採用すれば、「AからI」のコストを下げることができる。これは「AからIへの最短経路が求まった」という条件と矛盾する。以上から「最短経路の任意の二点間の経路も最短である」ことがわかる。</p>
<div class="figure">
<img src="fig/shortestpath4.png" alt="部分問題が解けている時の「最後の仕上げ」" />
<p class="caption">部分問題が解けている時の「最後の仕上げ」</p>
</div>
<p>これがどのように問題を解くのに使えるか考えてみよう。いま知りたいのは「AからI」までの最短経路である。しかし、それより小さい問題、「AからG」までの最短経路と、「AからH」までの最短経路がわかっているものとしよう。それぞれ「A-G」のコストが13、「A-H」のコストが11である。すると、「GからI」のコストが1、「HからI」のコストが2であることがわかっているので、AからG経由でIに行く最短パスのコストは14、AからH経由でIに行くコストは13となり、A-H-Iの経路が最短であることがわかる。</p>
<p>こうして、「問題が部分的に解けている」ならば、それを「再利用」することでより大きな問題が解けるでしょう、というのが動的計画法の骨子である。</p>
<h1 id="動的計画法課題">動的計画法：課題</h1>
<h2 id="課題1サイゼリヤ問題">課題1：サイゼリヤ問題</h2>
<p>組み合わせ最適化問題の例として、サイゼリヤ問題を取り上げよう。サイゼリヤ問題とは「N円持ってサイゼリヤに行ったら最大でどれだけのカロリーを摂取できるか」という問題である。ただし、同じメニューを重複して注文してはいけないことにする。これは典型的なナップサック問題である。サイゼリヤのメニューは日々変わっているが、ここではある時点でのメニュー、114品の金額とカロリーのデータを使い、最終的に「サイゼリヤに一万円を握りしめていったら、最大何kcalを摂取できるか」という問題を解く。</p>
<p>以下、サイゼリヤ問題を貪欲法、全探索、動的計画法の三種類の方法で解くことにする。新しいノートブックを開き、<code>saizeriya.ipynb</code>として保存せよ。</p>
<h3 id="課題1-1データの読み込み">課題1-1：データの読み込み</h3>
<h4 id="ライブラリのインポート">1. ライブラリのインポート</h4>
<p>まずはデータを読み込もう。いつも通り最初のセルで必要なものをimportする。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> pickle
<span class="im">from</span> collections <span class="im">import</span> defaultdict</code></pre></div>
<h4 id="データのロード">2. データのロード</h4>
<p>次に、データをロードしよう。二つ目のセルに以下を入力する。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">FILE<span class="op">=</span><span class="st">&#39;https://kaityo256.github.io/python_zero/dp/saizeriya.pickle&#39;</span>
<span class="op">!</span>wget $FILE</code></pre></div>
<p>最後に<code>‘saizeriya.pickle’ saved [5293/5293]</code>と表示されれば成功だ。</p>
<h4 id="データの読み込み">3. データの読み込み</h4>
<p>先程ダウンロードしたファイルは、pickleというライブラリでシリアライズされたデータである。これを読み込んでみよう。三つ目のセルに以下を入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;saizeriya.pickle&#39;</span>, <span class="st">&#39;rb&#39;</span>) <span class="im">as</span> f:
    names, prices, cals <span class="op">=</span> pickle.load(f)
names</code></pre></div>
<p>これは、114種類のメニューそれぞれの、名前、価格、カロリー(kcal)のリストである。読み込めたかどうか確認うるため、セルの最後で<code>names</code>を評価している。<code>「['彩りガーデンサラダ', '小エビのサラダ',,,'コーヒーゼリー','トリフアイスクリーム']</code>と表示されれば正しく読み込めている。</p>
<h3 id="課題1-2貪欲法">課題1-2：貪欲法</h3>
<p>読み込んだデータに対して、貪欲法を実装しよう。貪欲法をサイゼリヤ問題に当てはめると「値段あたりのカロリー」が高いものから順番に選び、予算を超えたらそこでストップ、というアルゴリズムとなる。アルゴリズムとしては以下のようになる。</p>
<ul>
<li>メニューを「値段あたりのカロリー」で降順にソートする</li>
<li>ソートした結果を上から順番に注文していく。ただし、予算オーバーするなら次を試す</li>
<li>全てのメニューを調べたら終了</li>
</ul>
<h4 id="貪欲法の実装">4. 貪欲法の実装</h4>
<p>4つ目のセルに、以下を入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> greedy(budget):
  ind <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(names)))
  ind <span class="op">=</span> <span class="bu">sorted</span>(ind, key<span class="op">=</span><span class="kw">lambda</span> x: cals[x]<span class="op">/</span>prices[x], reverse<span class="op">=</span><span class="va">True</span>)
  psum <span class="op">=</span> <span class="dv">0</span>
  csum <span class="op">=</span> <span class="dv">0</span>
  <span class="cf">for</span> i <span class="kw">in</span> ind:
    <span class="cf">if</span> psum <span class="op">+</span> prices[i] <span class="op">&gt;=</span> budget:
      <span class="cf">continue</span>
    psum <span class="op">+=</span> prices[i]
    csum <span class="op">+=</span> cals[i]
    <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> </span><span class="sc">{}</span><span class="st"> Yen </span><span class="sc">{}</span><span class="st"> kcal&quot;</span>.<span class="bu">format</span>(names[i], prices[i], cals[i]))
  <span class="bu">print</span>(<span class="st">&quot;Total </span><span class="sc">{}</span><span class="st"> Yen, </span><span class="sc">{}</span><span class="st"> kcal&quot;</span>.<span class="bu">format</span>(psum,csum))</code></pre></div>
<p>最後の<code>print</code>文のインデントが異なることに注意すること。</p>
<p>ここで、</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">  ind <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(names)))
  ind <span class="op">=</span> <span class="bu">sorted</span>(ind, key<span class="op">=</span><span class="kw">lambda</span> x: cals[x]<span class="op">/</span>prices[x], reverse<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<p>が、「メニューを価格あたりのカロリーでソートする」部分である。<code>list(range(len(names)))</code>は<code>[0,1,2,...,113]</code>という連番のインデックスを持つリストを作る部分である。このインデックスを、ある基準<code>key</code>でソートするようラムダ式で指定している。ラムダ式というと難しく聞こえるが、要するに</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">lambda</span> x: cals[x]<span class="op">/</span>prices[x]</code></pre></div>
<p>とは、「x」という値が与えられたら、<code>cals[x]/prices[x]</code>を返しなさい、という意味で、</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> key(x):
    <span class="cf">return</span> cals[x]<span class="op">/</span>prices[x]</code></pre></div>
<p>を一行で書いただけである。これにより、「値段あたりのカロリー」でソートできるが、<code>sorted</code>はデフォルトで昇順にソートするため、降順にするために<code>reverse=True</code>を指示している。</p>
<h4 id="貪欲法の実行">5. 貪欲法の実行</h4>
<p>早速貪欲法を実行してみよう。5つ目のセルで、以下を実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="op">%%</span>time
greedy(<span class="dv">1000</span>)</code></pre></div>
<p>さいしょの<code>%%time</code>は「実行時間を計測せよ」という意味だ。1000円で最大のカロリーを得るためのメニューが表示されたはずである。</p>
<p>さらに「一万円を握りしめてサイゼリヤにいったら、最大何kcalを摂取できるか」も考えてみよう。<code>1000</code>を<code>10000</code>に変えて</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="op">%%</span>time
greedy(<span class="dv">10000</span>)</code></pre></div>
<p>を実行せよ。結果はどうなるだろうか？出てきたメニューを見た感想を述べよ。</p>
<h3 id="課題1-3全探索">課題1-3：全探索</h3>
<p>動的計画法を実装する前に、全探索コードを書いてみよう。いま、メニューが114個ある。全てのメニューについて「注文する/しない」を選ぶと、全体で<span class="math inline">\(O(2^N)\)</span>の手間がかかる。ただし、すでに予算を超えている時に、さらに追加でメニューを注文する必要はないので、その部分は枝刈をする。これをナイーブに再帰で書いてみよう。</p>
<h4 id="全探索関数searchの実装">6. 全探索関数<code>search</code>の実装</h4>
<p><code>n</code>番目までのメニューを使って、<code>budget</code>円以内で得られる最大のカロリーを返す関数<code>search(n, budget)</code>を実装しよう。6つ目のセルに、以下を入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> search(n, budget):
  <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">0</span>:
    <span class="cf">return</span> <span class="dv">0</span>
  c1 <span class="op">=</span> <span class="dv">0</span>
  <span class="cf">if</span> prices[n] <span class="op">&lt;=</span> budget:
    c1 <span class="op">=</span> cals[n] <span class="op">+</span> search(n<span class="op">-</span><span class="dv">1</span>, budget <span class="op">-</span> prices[n])
  c2 <span class="op">=</span> search(n<span class="op">-</span><span class="dv">1</span>, budget)
  <span class="cf">return</span> <span class="bu">max</span>(c1,c2)</code></pre></div>
<p>一般に再帰による全探索コードは簡潔に書ける。「再帰の三カ条」を思い出そう。「再帰は自分自身を呼び出す」「最初に終端条件を書く」「問題をより小さくして自分自身を呼び出す」の三つが満たされていることを確認すること。</p>
<p>再帰の最初に書くのは終端処理だ。ここでは<code>n</code>を減らしながら再帰するので、<code>n &lt; 0</code>になったら終了としている。</p>
<p>次に、<code>n</code>番目のメニューを注文するか、しないかで二通りに分岐しながら再帰する。もし、<code>n</code>番目のメニューの値段が、現在の予算の範囲内であれば、それを採用した場合のカロリーは</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">c1 <span class="op">=</span> cals[n] <span class="op">+</span> search(n<span class="op">-</span><span class="dv">1</span>, budget <span class="op">-</span> prices[n])</code></pre></div>
<p>で得られる。ここで、<code>search(n-1, budget - prices[n])</code>は、「<code>n-1</code>番目までのメニューを使って、<code>budget-prices[n]</code>円で得られる最大カロリー」を返してくれるはずである。</p>
<p>また、n番目のメニューを注文しなかった場合は、そのメニューのカロリーが得られないかわりに、予算も減らないので、得られるカロリー<code>c2</code>は</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">c2 <span class="op">=</span> search(n<span class="op">-</span><span class="dv">1</span>, budget)</code></pre></div>
<p>で得られる。動作としてはトーナメントをイメージすればよい。各試合で、追加してきたメニュー同士で戦う。予算オーバーしたら失格、両者予算内なら、カロリーが多い方が勝ちである。これで最後まで勝ち残ったメニューが、予算内で最大のカロリーとなるはずだ。</p>
<h4 id="全探索の実行">7. 全探索の実行</h4>
<p>実際に全探索を実行してみよう。7つ目のセルで以下を実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="op">%%</span>time
cal <span class="op">=</span> search(<span class="bu">len</span>(names)<span class="op">-</span><span class="dv">1</span>,<span class="dv">1000</span>)
<span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> kcal&quot;</span>.<span class="bu">format</span>(cal))</code></pre></div>
<p>実行した結果、実行時間と1000円で得られる最大カロリーのみが表示されるはずである(メニューの取得は)。実行時間と結果を貪欲法と比較せよ。結果は貪欲法と一致したか？実行時間はどうであろうか？</p>
<p>次に<code>search(len(names)-1,1200)</code>と、予算を「1200円」にして実行してみよ。実行時間はどうなったであろうか？予算1万円の探索は実行可能できそうか？</p>
<p>なお、ここで求められるのは最大カロリーだけである。最大カロリーが求まった時、それを与えるメニューの組み合わせを求める方法は後述する。</p>
<h3 id="課題1-4メモ化再帰による動的計画法の実装">課題1-4：メモ化再帰による動的計画法の実装</h3>
<p>先ほどの全探索コードは、予算が増えるにしたがって指数関数的に時間がかかるので実用的でない。これを改善するのが「メモ化再帰」と呼ばれる方法だ。「メモ化再帰」は、簡単に言えば「再帰で組んだ全探索コードにメモ化というテクニックをつけたもの」だ。</p>
<p>ポイントは<code>search(n, budget)</code>の返す値は同じ<code>n</code>と<code>budget</code>の組み合わせについては同じ値を返す、という点である。特に<code>n</code>や<code>budget</code>が小さいところでは、同じ組み合わせが何度も呼ばれているため、それを毎回計算するのは無駄だ。そこで、一度計算した<code>(n, budget)</code>の組み合わせは、再利用することにしよう。やり方は簡単で、辞書を使うだけである。</p>
<h4 id="メモ化再帰の実装">8. メモ化再帰の実装</h4>
<p>8つ目のセルに、メモ化機能をつけた全探索ルーチン<code>search_memo</code>を実装しよう。<code># 追加(1)</code>などのコメントは入力しなくて良い。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> search_memo(n, budget):
  <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">0</span>:
    <span class="cf">return</span> <span class="dv">0</span>
  <span class="cf">if</span> dic[(n, budget)] <span class="kw">is</span> <span class="kw">not</span> <span class="dv">0</span>: <span class="co"># 追加(1)</span>
    <span class="cf">return</span> dic[(n, budget)]     <span class="co"># 追加(1)</span>
  c1 <span class="op">=</span> <span class="dv">0</span>
  <span class="cf">if</span> prices[n] <span class="op">&lt;=</span> budget:
    c1 <span class="op">=</span> cals[n] <span class="op">+</span> search_memo(n<span class="op">-</span><span class="dv">1</span>, budget <span class="op">-</span> prices[n])
  c2 <span class="op">=</span> search_memo(n<span class="op">-</span><span class="dv">1</span>, budget)
  cmax <span class="op">=</span> <span class="bu">max</span>(c1,c2)
  dic[(n, budget)] <span class="op">=</span> cmax <span class="co"># 追加(2)</span>
  <span class="cf">return</span> cmax</code></pre></div>
<p>先ほどの関数<code>search</code>に、3行追加しただけだ。</p>
<p>まず、新たな終端条件として「もしすでに調べた<code>(n, budget)</code>の組み合わせなら、計算済みの値を返す」という処理を追加したのが「追加(1)」だ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">  <span class="cf">if</span> dic[(n, budget)] <span class="kw">is</span> <span class="kw">not</span> <span class="dv">0</span>: <span class="co"># 追加(1)</span>
    <span class="cf">return</span> dic[(n, budget)]     <span class="co"># 追加(1)</span></code></pre></div>
<p>ここで、<code>n</code>と<code>budget</code>をまとめたタプル<code>(n, budget)</code>を辞書のキーとしている。</p>
<p>もし計算したことがない組み合わせなら、そのまま計算するが、せっかく計算したので、それを最後に覚えておく(メモしておく)のが「追加(2)」だ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">  dic[(n, budget)] <span class="op">=</span> cmax <span class="co"># 追加(2)</span></code></pre></div>
<p>これは<code>(n, budget)</code>の組み合わせで得られる最大カロリーを辞書に登録するコードだ。まるでメモを取って再利用しているようなので「 <strong>メモ化 (Memoization)</strong> 」と呼ぶ。メモ化は実装が簡単なわりに、極めて効果的な高速化テクニックである。</p>
<h4 id="メモ化再帰の実行">9. メモ化再帰の実行</h4>
<p>さて、早速実行してみよう。9つ目のセルで以下を実行せよ。まずは予算1000円から。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="op">%%</span>time
dic <span class="op">=</span> defaultdict(<span class="bu">int</span>)
cal <span class="op">=</span> search_memo(<span class="bu">len</span>(names)<span class="op">-</span><span class="dv">1</span>,<span class="dv">1000</span>)
<span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> kcal&quot;</span>.<span class="bu">format</span>(cal))</code></pre></div>
<p>メモ化に用いる辞書をここで定義していることに注意。全探索と同じ結果を、非常に高速に返したはずだ。特筆すべきは、実行時間の予算依存性である。全探索の場合は1000円を1200円にするだけで計算時間が激増した。しかし、メモ化を施した再帰ルーチンなら、10000円でも実行可能だ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="op">%%</span>time
dic <span class="op">=</span> defaultdict(<span class="bu">int</span>)
cal <span class="op">=</span> search_memo(<span class="bu">len</span>(names)<span class="op">-</span><span class="dv">1</span>,<span class="dv">10000</span>) <span class="co"># ←ここを10000に修正して再実行せよ</span>
<span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> kcal&quot;</span>.<span class="bu">format</span>(cal))</code></pre></div>
<p>出力された「最大摂取カロリー」を貪欲法によって得た結果と比較せよ。また、ここで得たカロリーは次の「発展課題：解の再構成」で使うので覚えておくこと。</p>
<h3 id="発展課題解の再構成">発展課題：解の再構成</h3>
<p>さて、メモ化再帰により、「ある予算内で得られる最大カロリー」はわかったが、「その最大カロリーを与えるメニュー」はわからない。しかし、先ほどメモしたリストと、最大カロリーがわかれば、そのメニューを構成するのは簡単である。</p>
<p>探索が終わったら、<code>dic[(n, budget)]</code>には、<code>n</code>番目のメニューまでを使って、予算<code>budget</code>内で得られる最大のカロリーがメモされているはずだ。再帰コードをもう一度見ると、この辞書が更新されるのは、メニュー<code>n</code>が注文されるか、されないかの二通りのどちらかだ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="co"># メニューnが注文される時</span>
dic[(n, budget)] <span class="op">=</span> cals[n] <span class="op">+</span> search(n<span class="op">-</span><span class="dv">1</span>, budget <span class="op">-</span> prices[n])

<span class="co"># メニューnが注文されない時</span>
dic[(n, budget)] <span class="op">=</span> search(n<span class="op">-</span><span class="dv">1</span>, budget)</code></pre></div>
<p>今、<code>n</code>番目のメニューまで使って、予算<code>budget</code>で最大<code>cal</code>カロリーが得られるとわかっているとしよう。このカロリー最大化メニューに<code>n</code>番のメニューが含まれていないならば、<code>dic[(n, budget)]</code>と<code>dic[(n-1, budget)]</code>が等しくなる。</p>
<p>従って、メニューを最後から順番にまわして、<code>dic[(n, budget)]</code>と<code>dic[(n-1, budget)]</code>が等しくなければ<code>n</code>をメニューに追加して予算とカロリーを減らし、そうでなければ次を探す、というループを回せばよい。この処理を実装してみよう。</p>
<h4 id="解の再構成get_menuの実装">10. 解の再構成<code>get_menu</code>の実装</h4>
<p>10個目のセルに、「予算」と「カロリー」から「メニュー」を再構成する関数<code>get_menu</code>を実装せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> get_menu(budget, cal):
  menu <span class="op">=</span> []
  <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="bu">len</span>(names))):
    <span class="cf">if</span> cal <span class="kw">is</span> <span class="dv">0</span>:
      <span class="cf">break</span>
    <span class="cf">if</span> dic[(n, budget)] <span class="kw">is</span> <span class="kw">not</span> dic[(n<span class="op">-</span><span class="dv">1</span>, budget)]:
      cal <span class="op">-=</span> cals[n]
      budget <span class="op">-=</span> prices[n]
      menu.append(n)
  <span class="cf">return</span> menu</code></pre></div>
<p>この関数が、「カロリー最大化メニュー」のインデックスリストを返す。</p>
<h4 id="メニューの表示関数show_menuの実装">11. メニューの表示関数<code>show_menu</code>の実装</h4>
<p><code>get_menu</code>が返すンデックスリストを受け取って、名前やカロリーを表示するコードも書こう。11個目のセルに以下を実装せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> show_menu(menu):
  <span class="cf">for</span> i <span class="kw">in</span> menu:
    <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> </span><span class="sc">{}</span><span class="st"> Yen </span><span class="sc">{}</span><span class="st"> kcal&quot;</span>.<span class="bu">format</span>(names[i], prices[i], cals[i]))
  total_price <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">map</span>(<span class="kw">lambda</span> x: prices[x], menu))
  total_cal <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">map</span>(<span class="kw">lambda</span> x: cals[x], menu))
  <span class="bu">print</span>(<span class="st">&quot;Total </span><span class="sc">{}</span><span class="st"> Yen </span><span class="sc">{}</span><span class="st"> kcal&quot;</span>.<span class="bu">format</span>(total_price, total_cal))</code></pre></div>
<h4 id="解の再構成">12. 解の再構成</h4>
<p>上記二つをまとめて実行してみよう。まずは1000円で得られる最大カロリーのメニューを見てみる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">budget <span class="op">=</span> <span class="dv">1000</span>
dic <span class="op">=</span> defaultdict(<span class="bu">int</span>)
cal <span class="op">=</span> search_memo(<span class="bu">len</span>(names)<span class="op">-</span><span class="dv">1</span>,budget)
menu <span class="op">=</span> get_menu(budget, cal)
show_menu(menu)</code></pre></div>
<p>貪欲法で得られたメニューが得られれば成功である。</p>
<p>同様に、予算一万円の場合のメニューも調べてみよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">budget <span class="op">=</span> <span class="dv">10000</span> <span class="co"># ここを10000にして再実行しよう</span>
dic <span class="op">=</span> defaultdict(<span class="bu">int</span>)
cal <span class="op">=</span> search_memo(<span class="bu">len</span>(names)<span class="op">-</span><span class="dv">1</span>,budget)
menu <span class="op">=</span> get_menu(budget, cal)
show_menu(menu)</code></pre></div>
<p>実行結果は是非自分の目で確認して欲しい。なお、成人男性が一日に摂取するカロリーが2000 kcalだそうである。カロリーと値段の関係を見てどう思ったか？</p>
<h2 id="余談エレファントな解法">余談：エレファントな解法</h2>
<p>チェス、将棋、囲碁、オセロといった「ゲーム」は、局面によって打てる「手」が決まっており、これを「合法手」と呼ぶ。何か「手」を打つと局面が変化し、また合法手も変化する。今、局面によって平均で4種類の合法手があり、勝負がつくまでに10手程度かかるゲームがあるとする。最終局面の数は4の10乗で、およそ100万通りである。もし勝負がつくまでに40手かかるとすると、4の40乗でおよそ一兆通りになる。このように、ゲームの状態数は、手の数に対して指数関数的に増えていく。このように、問題サイズに対して状態数が指数関数的に増えることを <strong>組み合わせ爆発</strong> と呼ぶ。組み合わせ爆発を題材にした、日本科学未来館の<a href="https://www.youtube.com/watch?v=Q4gTV4r0zRs">フカシギの数え方</a>という動画、通称「フカシギおねえさん」は面白いので是非一度見てみられたい。</p>
<p>一般に組み合わせ爆発が起きると計算機を使っても手も足もでないことが多いのだが、うまく「大きいけど有限」に問題を落とすことができると計算機で「読み切る」ことができる。その有名な例が四色問題であろう。四色問題とは「二次元の地図に対して、隣り合う領域を同じ色に塗らないという条件を満たしつつ全ての領域に色を塗るのに四色あれば足りるか」という命題である。簡単な地図を描くことで三色では足りないことがわかり、また六色あれば足りることの証明は容易である。五色で足りる証明(証明はかなり面倒だ)も提案されたが、四色で足りることの数学的な証明は長らくされなかった。四色問題が提起されてからおよそ100年後の1976年、アッペルとハーケンは、四色問題問題を「大きいが有限」の問題に帰着させ、その上でスパコンで力任せに「四色で足りる」ことを証明した。雑な言い方をすれば「この地図すべてを四色で塗ることができれば、いかなる地図も四色で塗ることができる」という「基礎地図(正確には不可避集合)」をすべてリストアップし、その「基礎地図」がすべて四色で塗り分けられることを示す、という方法である。</p>
<p>似たような「証明」に、「9×9の数独について、解が一意であるためには最低ヒントが17個必要である」という定理もある。これも、「すべての可能な数独の問題」に対して、それぞれに「すべての16ヒント問題」を作り、それが全て解が一意でないことをスパコンで力任せに確認することで証明された。このように「大きいが有限」の問題に帰着させて計算機で力任せに解いてしまうことを「エレファントな証明」と呼ぶ。数学の美しい証明を「エレガントな証明」と呼ぶことの対比である。</p>
<p>果たして「エレファントな証明」は人類を賢くしているのか？というのは難しい問題であり、現在もよく議論になる。例えばオセロも6×6マスまでは完全に解析されており(後手必勝である)、その知識を使えば、後手番なら絶対に負けない思考ルーチンを作ることができるのだが、果たしてそれは「思考」ルーチンといえるのだろうか？このような問題は、例えば<a href="https://ja.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E8%AA%9E%E3%81%AE%E9%83%A8%E5%B1%8B">中国語の部屋</a>という思考実験で問題提起されている。</p>
<p>私個人の意見としては、「エレファント」であろうと証明は証明だし、人類の知識を増やしたことは間違いないと考えている。ただし、それが「人類を賢くしたか」は別問題である。今後、「計算機が何か答えを出し、なぜかはわからないがそれが正しいように見える」ことが増えるであろう(天気予報が典型例だ)。このような「計算された知性」と人類はどう向き合うべきか、は難しい問題である。</p>
</article>
</body>
</html>
