<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>

<style>
    .btn-square {
      display: inline-block;
      padding: 0.5em 0.5em;
      text-decoration: none;
      background: #668ad8;
      color: #FFF;
      border-bottom: solid 4px #626295;
      border-radius: 5px;
    }

    .btn-square:active {
      -webkit-transform: translateY(4px);
      transform: translateY(4px);
      border-bottom: none;
    }
  .markdown-body {
    box-sizing: border-box;
    min-width: 200px;
    max-width: 980px;
    margin: 0 auto;
    padding: 45px;
  }
  p.caption{
    display:none;
  }
  img {width: 100%}

  @media (max-width: 767px) {
    .markdown-body {
      padding: 15px;
    }
  }
</style>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://kaityo256.github.io/python_zero/github-markdown.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
</head>
<body>
<article class="markdown-body">
<h1 id="リストとタプル"><a href="https://kaityo256.github.io/python_zero/list/">リストとタプル</a></h1>
<p><a href="../index.html">[Up]</a> <a href="https://github.com/kaityo256/python_zero">[Repository]</a></p>
<h2 id="本講で学ぶこと">本講で学ぶこと</h2>
<ul>
<li>リスト</li>
<li>タプル</li>
<li>値のコピーとリストのコピーの違い</li>
<li>参照の値渡し</li>
<li>リスト内包表記</li>
<li>コッホ曲線</li>
</ul>
<h2 id="リスト">リスト</h2>
<p>プログラムを組んでいると、何かひとまとまりのデータをまとめて保持し、処理したい場合がある。 そのようなデータ構造を表現するのがリスト(list)である。他の言語では配列(array)と呼ぶことが多い。</p>
<p>リストは<code>[]</code>の中に、カンマで区切って表現する。例えば、</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>とすると、整数の1,2,3を含むリストができる。</p>
<p>また、</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">[<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;C&quot;</span>]</code></pre></div>
<p>とすると、文字列のリストができる。リストにはどんなものも入れることができる。また、異なる種類のものを混ぜて入れることもできる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">[<span class="st">&quot;A&quot;</span>, <span class="dv">1</span>, <span class="fl">1.0</span>]</code></pre></div>
<p>変数にリストを代入することもできる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre></div>
<p>リストの要素には、<code>[]</code>でアクセスできる。例えば<code>a</code>の最初の要素が欲しい場合は<code>a[0]</code>とする。カッコの中の数字を <strong>添え字(index)</strong> と呼ぶ。言語によって、添え字が0始まりの場合と1始まりの場合がある。Pythonは0始まりである。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
a[<span class="dv">0</span>] <span class="co"># =&gt; 1</span></code></pre></div>
<p>要素に値を代入することができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
a[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">4</span>
a <span class="co"># =&gt; [1,4,3]</span></code></pre></div>
<p>リストは入れ子にすることもできる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>],<span class="dv">5</span>]</code></pre></div>
<p>入れ子になったリストは、添え字を複数指定することで要素を得ることができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>],<span class="dv">5</span>]
a[<span class="dv">0</span>] <span class="co">#=&gt; [1,2]</span>
a[<span class="dv">0</span>][<span class="dv">1</span>] <span class="co">#=&gt; 2</span></code></pre></div>
<p>リストの長さは<code>len</code>という関数で取得できる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
<span class="bu">len</span>(a) <span class="co"># =&gt; 3</span></code></pre></div>
<p>二つのリストを結合することができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">[<span class="dv">1</span>,<span class="dv">2</span>] <span class="op">+</span> [<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>] <span class="co"># =&gt; [1,2,3,4,5]</span></code></pre></div>
<p>要素を追加する場合は<code>append</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>]
a.append(<span class="dv">3</span>)
a <span class="co"># =&gt; [1,2,3]</span></code></pre></div>
<p>リストを<code>append</code>する場合には注意が必要である。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> []
b <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>]
a.append(b)
a.append(b)</code></pre></div>
<p>とすると、見かけ上<code>a</code>は二行二列の行列のように見える。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="bu">print</span>(a) <span class="co">#=&gt; [[1, 2], [1, 2]]</span></code></pre></div>
<p>しかし、要素に含まれる二つのリストは同じものであるから、一方を修正するともう一方も影響を受ける。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">4</span>
<span class="bu">print</span>(a) <span class="co">#=&gt; [[4, 2], [4, 2]]</span></code></pre></div>
<p>なぜこうなるかは、後述する「リストのメモリ上での表現」を知れば理解できるであろう。</p>
<p>リストに要素が含まれるかどうかは、<code>in</code>で調べることができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
<span class="dv">1</span> <span class="kw">in</span> a <span class="co"># =&gt; True</span>
<span class="dv">4</span> <span class="kw">in</span> a <span class="co">#=&gt; False</span></code></pre></div>
<p>リストの要素を順番に取り出しながら、すべての要素について処理をしたい場合、<code>for</code>と<code>in</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;C&quot;</span>]
<span class="cf">for</span> i <span class="kw">in</span> a:
  <span class="bu">print</span>(i)</code></pre></div>
<h2 id="タプル">タプル</h2>
<p>タプル(tuple)は、複数の値の組を表現するデータ構造である。タプルはカンマで区切られた値で表現されるが、紛らわしいときには丸カッコ<code>()</code>で囲む。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>
a <span class="co">#=&gt; (1, 2, 3)</span></code></pre></div>
<p>タプルはリストと同様に<code>len</code>で長さを得たり、添え字で要素を得ることができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>
a[<span class="dv">0</span>] <span class="co">#=&gt; 1</span>
<span class="bu">len</span>(a) <span class="co">#=&gt; 3</span></code></pre></div>
<p>タプルの結合もできる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">(<span class="dv">1</span>,<span class="dv">2</span>) <span class="op">+</span> (<span class="dv">3</span>,<span class="dv">4</span>) <span class="co"># =&gt; (1,2,3,4)</span></code></pre></div>
<p>このようにタプルはリストに似ているが、一度作成されたタプルは修正できない。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
a[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">4</span> <span class="co">#=&gt; &#39;tuple&#39; object does not support item assignment</span></code></pre></div>
<p>タプルは関数で複数の値を返したい場合によく使われる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> func():
  <span class="cf">return</span> <span class="dv">1</span>,<span class="dv">2</span>

func() <span class="co">#=&gt; (1,2)</span></code></pre></div>
<p>タプルを使って、複数の変数を一度に初期化することができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a, b <span class="op">=</span> <span class="dv">1</span>, <span class="dv">2</span>
a <span class="co">#=&gt; 1</span>
b <span class="co">#=&gt; 2</span></code></pre></div>
<p>以下のようにすると、変数の値の交換ができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a, b <span class="op">=</span> b, a</code></pre></div>
<p>タプルのリストを作ることもできる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>), (<span class="dv">3</span>,<span class="dv">4</span>)]</code></pre></div>
<p>その場合、例えば0番目の要素を以下のように変数に代入できる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>), (<span class="dv">3</span>,<span class="dv">4</span>)]
x, y <span class="op">=</span> a[<span class="dv">0</span>] <span class="co"># x = 1, y = 2になる</span></code></pre></div>
<h2 id="enumerate">enumerate</h2>
<p><code>for x in a:</code>という構文で、リスト<code>a</code>のそれぞれの要素<code>x</code>について処理をすることができる。しかし、たまに「要素の値」と、「その要素がリストの何番目にあるか」の情報が両方欲しい場合がある。その時に使うのが<code>enumerate</code>だ。</p>
<p>リスト<code>a</code>について、<code>enumerate(a)</code>とすると、要素のインデックスと要素の内容をペアで受け取ることができる。</p>
<p>例えば、こんなことができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;C&quot;</span>]
<span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">enumerate</span>(a):
  <span class="bu">print</span>(i, x)</code></pre></div>
<p>ここでは、インデックスを<code>i</code>で、要素を<code>x</code>で受け取っている。</p>
<p>実行結果はこうなる。</p>
<pre class="txt"><code>0 A
1 B
2 C</code></pre>
<p>リストとタプルについて覚えて起きたいことは他にもいろいろあるが、それは必要に応じて説明していくことにしよう。</p>
<h2 id="リストのメモリ上の表現">リストのメモリ上の表現</h2>
<p>さて、リストがメモリ上でどのように表現されているか見てみよう。すでに、「変数とはラベルである」と学んだ。これはリストにおいても変わらないが、リストは複数の要素を含むため、リストを表すラベルは「リストの先頭位置」を指す。</p>
<div class="figure">
<img src="fig/list.png" alt="リストのメモリ上での表現" />
<p class="caption">リストのメモリ上での表現</p>
</div>
<p>例えば、<code>a = [1, 2, 3]</code>という命令を見てみよう。これは、</p>
<ul>
<li>メモリ上に<code>[1, 2, 3]</code>というリストを作成し、</li>
<li>その先頭位置を指す場所を作成して、そこに<code>a</code>というラベルをつける</li>
</ul>
<p>という操作から構成される。ここで、<code>a</code>が「リストの先頭そのもの」ではなく、「リストの先頭を指す場所」を指していることに注意。この仕様から、リストをコピーする際には注意が必要となる。</p>
<div class="figure">
<img src="fig/copy_value.png" alt="値のコピー" />
<p class="caption">値のコピー</p>
</div>
<p>まず、普通の変数のコピーを見てみよう。例えば<code>10</code>という値を指す変数<code>a</code>を<code>b</code>にコピーし、その後<code>b</code>に<code>20</code>を代入する操作を考える。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> <span class="dv">10</span>
b <span class="op">=</span> a
b <span class="op">=</span> <span class="dv">20</span></code></pre></div>
<p>この時、</p>
<ul>
<li><code>a = 10</code>：メモリ上に「10」を表現する場所が作られて、そこに<code>a</code>というラベルを貼る</li>
<li><code>b = a</code> ：<code>a</code>の指す値をコピーしてから、そこに<code>b</code>というラベルを貼る</li>
<li><code>b = 20</code> : <code>b</code>の指す値を<code>20</code>に書き換える</li>
</ul>
<p>という操作が行われている。</p>
<p>さて、<code>b = a</code>として他の変数にリストをコピーすると、整数等の場合と同様に、「ラベルの指している場所の値をコピーして、そこにラベルを貼る」という操作が行われる。この時コピーされるのは「リストの先頭の場所」という情報であるから、<code>a</code>と<code>b</code>のラベルは同じリストを指すことになる。したがって、<code>b</code>を通じてリストを修正すると、<code>a</code>が指すリストも修正されることになる。</p>
<div class="figure">
<img src="fig/copy_list.png" alt="リストのコピー" />
<p class="caption">リストのコピー</p>
</div>
<p>また、同じリストを指している変数<code>a</code>、<code>b</code>がある時、<code>b</code>に異なるリストを代入すると、それぞれ別のリストを指す。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
b <span class="op">=</span> a
b <span class="op">=</span> [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]</code></pre></div>
<p>これは<code>b=a</code>を実行した時点では<code>a</code>と<code>b</code>は同じリストを指しているが、<code>b = [4, 5, 6]</code>を実行すると、まずメモリ上に<code>[4, 5, 6]</code>を表現するデータが作られ、その後<code>b</code>の指す内容が新しく作られたリストの先頭データとなるため、<code>a</code>と<code>b</code>が無関係となるためである。</p>
<div class="figure">
<img src="fig/copy_list2.png" alt="コピー後のリストの代入" />
<p class="caption">コピー後のリストの代入</p>
</div>
<p>リストを指す変数は、リストそのものではなく、リストの先頭の場所を記録した情報を指している。 このように、値そのものではなく、「この場所を見よ」というような情報を「参照(reference) 」と呼ぶ。</p>
<h2 id="参照の値渡しについて">参照の値渡しについて</h2>
<p>前回「関数」を学び、今回「リスト」を学んだ。これにより、関数の引数としてリストを受け渡せるようになった。この時、注意すべきことがある。</p>
<p>まず、関数の引数は、関数が作るブロック内だけで有効なローカル変数である。グローバル変数と同じ名前をつけても、別の変数として扱われる。</p>
<p>こんなコードを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> func(a):
  a <span class="op">=</span> <span class="dv">2</span>

a <span class="op">=</span> <span class="dv">1</span>
func(a)
<span class="bu">print</span>(a) <span class="co">#=&gt; 1</span></code></pre></div>
<p>関数<code>func</code>は、引数として変数<code>a</code>を受け取る。この時、<code>a</code>の値がコピーされ、「関数内のローカル変数<code>a</code>」が作成される。この変数<code>a</code>は関数内だけで有効なので、関数内で値を変更しても、外部の変数である<code>a</code>に影響は与えない。</p>
<div class="figure">
<img src="fig/ref1.png" alt="関数の引数の受け渡し" />
<p class="caption">関数の引数の受け渡し</p>
</div>
<p>このように、関数の引数としてグローバル変数と同じ名前を使ったり、関数内でグローバル変数と同じ名前のローカル変数を宣言しても、グローバル変数とは別の変数として扱われる(バグの元なのでやってはならない)。また「関数の引数は値をコピーして渡される」ことは覚えておいて欲しい。</p>
<p>次に、関数の引数としてリストを渡してみよう。リストを表す変数は、リストの「先頭」を指していることは既に説明した。それ以外は先程と同じで、関数の引数は、値がコピーされて渡される。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> func(b):
    b[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">4</span>

a <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
func(a)
<span class="bu">print</span>(a) <span class="co">#=&gt; [1,4,3]</span></code></pre></div>
<div class="figure">
<img src="fig/ref2.png" alt="リストを関数に渡した場合" />
<p class="caption">リストを関数に渡した場合</p>
</div>
<p>先程説明した、リストのコピーをした時とまったく同じことが起きて、関数内でリストを修正すると、関数の外部でもリストが修正される。</p>
<p>また、引数として受け取ったリストに、あらたにリストを代入すると、それは関数ローカルだけで有効になり、外部のリストに影響を与えなくなるのも理解できるであろう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> func(b):
    b <span class="op">=</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>] <span class="co"># bにあらたなリストを代入</span>

a <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
func(a)
<span class="bu">print</span>(a) <span class="co">#=&gt; [1,2,3] aは影響を受けない</span></code></pre></div>
<div class="figure">
<img src="fig/ref3.png" alt="関数内で引数にリストを代入した場合" />
<p class="caption">関数内で引数にリストを代入した場合</p>
</div>
<p>このように、関数の引数に値をコピーして渡す方法を「<strong>値渡し(call by value)</strong>」と呼ぶ。Pythonは関数には値がコピーして渡されるため、値渡しとなる。</p>
<p>また、リストを指す変数は、リストの値そのものではなく、リストの先頭の場所を指している。このような値の持ち方を「<strong>参照(reference)</strong>」と呼ぶ。</p>
<p>リストを指す変数を関数に渡す時、「リストの先頭の場所」という「参照」の「値」をコピーして渡すので、「<strong>参照の値渡し</strong>」と呼ばれる。いずれにせよ、やっていることは変数の値をコピーして渡しているだけであるが、その変数が参照であるかどうかによって挙動が変わって見える。より正確にはミュータブルかイミュータブルかなのだが、ここでは深入りしない。</p>
<p>この仕組みをきっちりと覚えておく必要はない。しかし、将来プログラムでこの問題にハマった時に、「あ、参照の値渡しか」と思い出せると、問題解決が早いであろう。ここではぼんやりと「そういう問題もある」と覚えておけばよい。</p>
<h2 id="リスト内包表記">リスト内包表記</h2>
<div class="figure">
<img src="fig/report.png" alt="大量のレポートを採点する教員" />
<p class="caption">大量のレポートを採点する教員</p>
</div>
<p>日常業務において、何かまとまったデータを受け取り、それに何か処理をして、まとまったデータとして返す、という処理は非常に多い。例えば講義でレポートを出したら、全員分のレポートを受け取り、それを採点して、それぞれに成績をつける、という処理をしなければならない。</p>
<p>同様に、プログラムでも、何かリストを受け取り、そのリストに何か処理をして、新しいリストを作成する、という処理をすることが多い。</p>
<p>簡単な例として、整数のリストを受け取って、要素をすべて二倍にしたリストを作成するようなコードを書こう。普通にループを回すとこんな感じに書けるであろう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">source <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>]
result <span class="op">=</span> []
<span class="cf">for</span> i <span class="kw">in</span> source:
    result.append(i<span class="op">*</span><span class="dv">2</span>)</code></pre></div>
<p>Pythonには、「<strong>リスト内包表記 (List Comprehension)</strong>」という表記法があり、上記のコードは以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">source <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>]
result <span class="op">=</span> [<span class="dv">2</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> source]</code></pre></div>
<p>リスト内包表記は</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">[新しいリストの要素 <span class="cf">for</span> 元のリストの要素 <span class="kw">in</span> 元のリスト]</code></pre></div>
<p>という書き方をする。リスト内包表記は「後ろから」読むのがコツである。</p>
<p>つまり、</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">[<span class="dv">2</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> source]</code></pre></div>
<p>という内包表記は、</p>
<ul>
<li><code>source</code>というリストに含まれる</li>
<li>それぞれの要素<code>i</code>について</li>
<li><code>2*i</code>を要素とするような新しいリストを作ってください</li>
</ul>
<p>という意味となる。</p>
<div class="figure">
<img src="fig/list_comp.png" alt="リスト内包表記" />
<p class="caption">リスト内包表記</p>
</div>
<p>もちろん<code>source</code>のところに直接リストを入れてしまって、</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">result <span class="op">=</span> [<span class="dv">2</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>]]</code></pre></div>
<p>としてもかまわない。また、<code>range</code>を使って</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">result <span class="op">=</span> [<span class="dv">2</span><span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>)]</code></pre></div>
<p>と書くこともできる。</p>
<h2 id="コッホ曲線">コッホ曲線</h2>
<p>リストやタプルについて学んだので、それを利用して「コッホ曲線」を描画してみよう。</p>
<p>コッホ曲線を知っているだろうか。こんな図形である。</p>
<div class="figure">
<img src="fig/koch.png" alt="コッホ曲線" />
<p class="caption">コッホ曲線</p>
</div>
<p>名前を知らなくても、その形は見たことがあるかと思う。この曲線は、以下のような手続きで作成される。</p>
<ol style="list-style-type: decimal">
<li>まず線分を用意する</li>
<li>線分を三等分する</li>
<li>中央の線分を、正三角形の形に盛り上げる</li>
</ol>
<p>この手続きをすると、一本の線分が4本の線分に変換される。こうしてできた4本の線分のそれぞれに同様な手続きを繰り返すと、コッホ曲線ができあがる。</p>
<div class="figure">
<img src="fig/koch2.png" alt="コッホ曲線の作り方" />
<p class="caption">コッホ曲線の作り方</p>
</div>
<p>コッホ曲線は、再帰を使って描画するのが自然だが、今回はリストとタプルを駆使してコッホ曲線を描くプログラムを組んでみよう。</p>
<p>コッホ曲線とは、すべてつながった線分から構成されている。したがって、ある点から、次の点へのベクトルの集合とみなすことができる。さて、あるベクトルが与えられたとき、それをどのように変換したいかを表現したベクトルのリストを与えて変換することを考える。</p>
<div class="figure">
<img src="fig/koch3.png" alt="ベクトルの変換" />
<p class="caption">ベクトルの変換</p>
</div>
<p>コッホ曲線では、最初にx方向に伸びた長さ1の線分がある。これを二次元ベクトル<span class="math inline">\((1,0)\)</span>で表現する。これを入力したら<span class="math inline">\((1/3, 0), (1/6, \sqrt{3}/6), (1/6, -\sqrt{3}/6), (1/3,0)\)</span>の4つのベクトルに変換したい。ここで、最初に与えたベクトルと、変換で与えたベクトルの始点から終点の長さが等しいことに注意せよ。ただ、変換リストを、長さを考えながら与えるのは面倒だ。変換リストとして<span class="math inline">\((1, 0), (1/2, \sqrt{3}/2), (1/2, -\sqrt{3}/2), (1,0)\)</span>を与えたら、長さを自動調節するようにしよう。 また、傾いたベクトルを入力したら、傾いた4つのベクトルにする。</p>
<p>このような変換プログラムを書いたら、最初にタプルのリスト<code>[(1,0)]</code>を入力すると、それを変換した4つのタプルのリストに変換され、さらにそれを変換したら16個のタプルのリストに変換され・・・と、この処理を繰り返すことでコッホ曲線を表現するベクトルのリストを作ることができる。以下、そのプログラムを少しずつ作っていこう。</p>
<h1 id="リストとタプル課題">リストとタプル：課題</h1>
<h2 id="課題1コッホ曲線">課題1：コッホ曲線</h2>
<h3 id="課題1-1コッホ曲線の描画">課題1-1：コッホ曲線の描画</h3>
<p>新しいノートブックを開き、<code>koch.ipynb</code>という名前にせよ。</p>
<p>最初と次のセルに以下を入力せよ。</p>
<h4 id="ライブラリのインポート">1. ライブラリのインポート</h4>
<p>1つ目のセルでは、必要なライブラリをインポートする。ここでは<code>math</code>ライブラリの平方根<code>sqrt</code>と、描画に必要なライブラリをインポートしている。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">from</span> math <span class="im">import</span> sqrt
<span class="im">from</span> PIL <span class="im">import</span> Image, ImageDraw
<span class="im">from</span> IPython.display <span class="im">import</span> display</code></pre></div>
<h4 id="ベクトルの和の長さ">2. ベクトルの和の長さ</h4>
<p>長さの自動調節のため、変換ベクトルのリストが与えられたら、始点と終点を結ぶベクトルの長さを求めよう。変換ベクトルリストは、タプルのリストとして与える。例えば<code>[(1,0),(0,1)]</code>のようなリストが与えられた時に、<span class="math inline">\(\sqrt{2} \sim 1.414\)</span>を返すような関数<code>length</code>を実装したい。</p>
<p>これは要するにベクトルのリストを受けとって、そのベクトルの和を計算してから、得られたベクトルの長さを返す関数を作ればよい。2つ目のセルに以下を入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> length(a):
    x, y <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span>
    <span class="cf">for</span> (dx, dy) <span class="kw">in</span> a:
        x <span class="op">+=</span> dx
        y <span class="op">+=</span> dy
    <span class="cf">return</span> sqrt(x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span>)</code></pre></div>
<p>ここで<code>a</code>は、タプルのリスト、例えば<code>[(1,0),(0,1)]</code>のような入力を想定している。<code>for (dx, dy) in a:</code>は、リスト<code>a</code>に含まれるタプルを直接<code>(dx, dy)</code>というタプルで受け取るという意味で、冗長に書けば</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="cf">for</span> ai <span class="kw">in</span> a:
  dx, dy <span class="op">=</span> ai</code></pre></div>
<p>と同じ意味である。</p>
<p>入力したら、3つ目のセルを使って動作確認をしよう。以下を実行してみよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]
length(a)</code></pre></div>
<p>次のような表示がなされれば正しく入力されている。</p>
<pre class="txt"><code>1.4142135623730951</code></pre>
<p>確認が終わったら、3つ目のセルを削除すること。</p>
<h4 id="タプルからリストを作成">3. タプルからリストを作成</h4>
<p>次に、入力ベクトルを、変換ベクトルリストに基づいて変換することを考えよう。処理は以下の通りである。</p>
<ul>
<li>入力ベクトルの長さと変換ベクトルリストの長さの比<code>scale</code>を求める</li>
<li>入力ベクトルの傾き角度<span class="math inline">\(\theta\)</span>の<span class="math inline">\(sin\)</span>と<span class="math inline">\(cos\)</span>の値を求める</li>
<li>変換ベクトルリストに含まれるベクトルそれぞれについて、<code>scale</code>倍して<span class="math inline">\(\theta\)</span>だけ傾けたものをリストに追加する</li>
</ul>
<p>以上を実現する以下のコードを、3つ目のセルに入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> convert(a, b):
    ax, ay <span class="op">=</span> a
    alen <span class="op">=</span> sqrt(ax<span class="op">**</span><span class="dv">2</span><span class="op">+</span>ay<span class="op">**</span><span class="dv">2</span>)
    c <span class="op">=</span> ax<span class="op">/</span>alen
    s <span class="op">=</span> ay<span class="op">/</span>alen
    scale <span class="op">=</span> alen<span class="op">/</span>length(b)
    b <span class="op">=</span> [(scale<span class="op">*</span>x, scale<span class="op">*</span>y) <span class="cf">for</span> (x, y) <span class="kw">in</span> b]
    b <span class="op">=</span> [(c <span class="op">*</span> x <span class="op">-</span> s<span class="op">*</span> y, s <span class="op">*</span>x <span class="op">+</span> c <span class="op">*</span> y) <span class="cf">for</span> (x, y) <span class="kw">in</span> b]
    <span class="cf">return</span> b</code></pre></div>
<p>上記を実装したら、4つ目のセルで動作確認をしよう。</p>
<p>例えば入力として<span class="math inline">\((0,1)\)</span>というベクトルを、変換リストとして<code>[(1,1),(-1,1)]</code>というリストを与えたら、<code>[(-0.5, 0.5), (-0.5, -0.5)]</code>という出力が得られなくてはならない。</p>
<p>入力</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> (<span class="dv">0</span>,<span class="dv">1</span>)
b <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)]
convert(a,b)</code></pre></div>
<p>出力</p>
<pre class="txt"><code> [(-0.5, 0.5), (-0.5, -0.5)]</code></pre>
<p>正しい動作が確認できたら、テスト用のセルを削除しておこう。</p>
<h4 id="タプルのリストそれぞれに適用">4. タプルのリストそれぞれに適用</h4>
<p>今、「ベクトルをタプルとして与えられたら、変換ベクトルリストに従って、タプルのリストに変換する関数」を<code>convert</code>として実装した。これを使えば、「タプルのリスト」が与えられたとき、それぞれのタプルに<code>convert</code>を適用した結果をまとめたリストを作る関数<code>apply</code>は簡単に実装できる。以下を4つ目のセルに入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> <span class="bu">apply</span>(a, b):
    r <span class="op">=</span> []
    <span class="cf">for</span> i <span class="kw">in</span> a:
        r <span class="op">+=</span> convert(i, b)
    <span class="cf">return</span> r</code></pre></div>
<p>入力したら動作確認しよう。5つ目のセルに以下を実行し、結果が正しいことを確認せよ。</p>
<p>入力</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]
b <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)]
<span class="bu">apply</span>(a,b)</code></pre></div>
<p>出力</p>
<pre class="txt"><code>[(0.5, 0.5), (-0.5, 0.5), (-0.5, 0.5), (-0.5, -0.5)]</code></pre>
<p>動作確認ができたら、テスト用のコード(5つ目のセル)は削除してよい。</p>
<h4 id="線の描画">5. 線の描画</h4>
<p>ベクトルのリストが与えられたら、描画するのは難しくない。与えられたベクトルの通りに線を描画すればよい。ただし、線を描画したら、次に描画する始点を、現在の終点に取り直す必要がある。</p>
<p>以下のプログラムを、5つ目のセルに入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> draw_line(draw, a):
    x1, y1 <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span>
    <span class="cf">for</span> (dx, dy) <span class="kw">in</span> a:
        x2 <span class="op">=</span> x1 <span class="op">+</span> dx
        y2 <span class="op">=</span> y1 <span class="op">+</span> dy
        draw.line((x1, y1, x2, y2), fill<span class="op">=</span>(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>))
        x1, y1 <span class="op">=</span> x2, y2</code></pre></div>
<p>これは、ベクトルのリストを受け取り、そのベクトルの通りに線を描画する関数である。</p>
<h4 id="画像の表示">6. 画像の表示</h4>
<p>では、最後に描画してみよう。以下のコードを7つ目のセルに入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">size <span class="op">=</span> <span class="dv">512</span>
N <span class="op">=</span> <span class="dv">1</span>
im <span class="op">=</span> Image.new(<span class="st">&quot;RGB&quot;</span>, (size, size))
draw <span class="op">=</span> ImageDraw.Draw(im)
a <span class="op">=</span> [(size, <span class="dv">0</span>)]
b <span class="op">=</span> [(<span class="dv">1</span>, <span class="dv">0</span>), (<span class="fl">0.5</span>, sqrt(<span class="fl">3.0</span>)<span class="op">/</span><span class="dv">2</span>), (<span class="fl">0.5</span>, <span class="op">-</span>sqrt(<span class="fl">3.0</span>)<span class="op">/</span><span class="dv">2</span>), (<span class="dv">1</span>, <span class="dv">0</span>)]
<span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(N):
  a <span class="op">=</span> <span class="bu">apply</span>(a, b)
draw_line(draw, a)
display(im)</code></pre></div>
<p>ここまで正しく入力できていれば、下向きの三角形が一つ表示されたはずだ。これはコッホ曲線の一段階目の変換をした画像である。</p>
<p>できていたら、<code>N</code>の数字を一つずつ増やしてみよ。最大でも5くらいにとどめておくこと。</p>
<h3 id="課題1-2オリジナルのフラクタル曲線">課題1-2：オリジナルのフラクタル曲線</h3>
<p>6つ目のセルの<code>b</code>のリストに好きなベクトル列を入れて、オリジナルのフラクタル曲線を作成せよ。</p>
<p>例えば、繰り返し数を<code>N=1</code>としてから、</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">b <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">0</span>)]</code></pre></div>
<p>として描画し、繰り返し数を増やした場合にどんな図形になるか想像してみよ。想像した後に<code>N=5</code>に変えて描画し、想像と合致していたか確認せよ。</p>
<h3 id="発展課題">発展課題</h3>
<p>コッホ曲線の線分に色を塗るプログラムを組んでみよう。</p>
<h4 id="線に色を塗る">7. 線に色を塗る</h4>
<p>7つ目のセルに、色付きの線を塗る関数<code>draw_line_color</code>を入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> draw_line_color(draw, a, c):
    x1, y1 <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span>
    clen <span class="op">=</span> <span class="bu">len</span>(c)
    <span class="cf">for</span> i, (dx, dy) <span class="kw">in</span> <span class="bu">enumerate</span>(a):
        x2 <span class="op">=</span> x1 <span class="op">+</span> dx
        y2 <span class="op">=</span> y1 <span class="op">+</span> dy
        draw.line((x1, y1, x2, y2), fill<span class="op">=</span>c[i<span class="op">%</span>clen])
        x1, y1 <span class="op">=</span> x2, y2</code></pre></div>
<h4 id="色付きのフラクタル図形">8. 色付きのフラクタル図形</h4>
<p>8つ目のセルに、<code>draw_line_color</code>を使った描画プログラムを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">size <span class="op">=</span> <span class="dv">512</span>
N <span class="op">=</span> <span class="dv">1</span>
im <span class="op">=</span> Image.new(<span class="st">&quot;RGB&quot;</span>, (size, size))
draw <span class="op">=</span> ImageDraw.Draw(im)
a <span class="op">=</span> [(size, <span class="dv">0</span>)]
b <span class="op">=</span> [(<span class="dv">1</span>, <span class="dv">0</span>), (<span class="fl">0.5</span>, sqrt(<span class="fl">3.0</span>)<span class="op">/</span><span class="dv">2</span>), (<span class="fl">0.5</span>, <span class="op">-</span>sqrt(<span class="fl">3.0</span>)<span class="op">/</span><span class="dv">2</span>), (<span class="dv">1</span>, <span class="dv">0</span>)]
c <span class="op">=</span> [(<span class="dv">255</span>,<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">255</span>),(<span class="dv">0</span>,<span class="dv">255</span>,<span class="dv">0</span>)]
<span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(N):
    a <span class="op">=</span> <span class="bu">apply</span>(a, b)
draw_line_color(draw, a, c)
display(im)</code></pre></div>
<p>成功したら、<code>N</code>の数字を一つずつ増やしてみよ。また、変換ベクトルリスト<code>b</code>や、色のリスト<code>c</code>を適当に修正し、オリジナルのフラクタル図形を作成してみよ。</p>
<h3 id="内包表記">内包表記</h3>
<p>リスト内包表記を使うとコードを簡潔に書くことができる。先程書いた<code>convert</code>関数を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> convert(a, b):
    ax, ay <span class="op">=</span> a
    alen <span class="op">=</span> sqrt(ax<span class="op">**</span><span class="dv">2</span><span class="op">+</span>ay<span class="op">**</span><span class="dv">2</span>)
    c <span class="op">=</span> ax<span class="op">/</span>alen
    s <span class="op">=</span> ay<span class="op">/</span>alen
    scale <span class="op">=</span> alen<span class="op">/</span>length(b)
    b <span class="op">=</span> [(scale<span class="op">*</span>x, scale<span class="op">*</span>y) <span class="cf">for</span> (x, y) <span class="kw">in</span> b]
    b <span class="op">=</span> [(c <span class="op">*</span> x <span class="op">-</span> s<span class="op">*</span> y, s <span class="op">*</span>x <span class="op">+</span> c <span class="op">*</span> y) <span class="cf">for</span> (x, y) <span class="kw">in</span> b]
    <span class="cf">return</span> b</code></pre></div>
<p><code>b</code>に関してリスト内包表記を使っている部分がある。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">    b <span class="op">=</span> [(scale<span class="op">*</span>x, scale<span class="op">*</span>y) <span class="cf">for</span> (x, y) <span class="kw">in</span> b]
    b <span class="op">=</span> [(c <span class="op">*</span> x <span class="op">-</span> s<span class="op">*</span> y, s <span class="op">*</span>x <span class="op">+</span> c <span class="op">*</span> y) <span class="cf">for</span> (x, y) <span class="kw">in</span> b]
    <span class="cf">return</span> b</code></pre></div>
<p>これは、</p>
<ul>
<li>タプルのリスト<code>b</code>の要素<code>(x,y)</code>それぞれについて、まず<code>(x,y)</code>をそれぞれ<code>scale</code>倍したリストを作成せよ</li>
<li>そうしてできた新しいリスト<code>b</code>の要素<code>(x,y)</code>それぞれについて、<code>(c * x - s* y, s *x + c * y)</code>という変換(回転行列の演算)をしたリストを作成せよ</li>
<li>できたリストを<code>b</code>返せ</li>
</ul>
<p>という意味だ。毎回<code>b</code>に上書き代入していることに注意。</p>
<p>これを、<code>for</code>文で書くとこのようになるだろう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">    r <span class="op">=</span> []
    <span class="cf">for</span> (bx, by) <span class="kw">in</span> b:
        bx <span class="op">*=</span> scale
        by <span class="op">*=</span> scale
        nx <span class="op">=</span> c <span class="op">*</span> bx <span class="op">-</span> s <span class="op">*</span> by
        ny <span class="op">=</span> s <span class="op">*</span> bx <span class="op">+</span> c<span class="op">*</span>by
        r.append((nx, ny))
    <span class="cf">return</span> r</code></pre></div>
<p>これは</p>
<ul>
<li><code>r</code>という空リストを作成しておく</li>
<li><code>b</code>の要素を<code>(bx, by)</code>というタプルで受け取る</li>
<li><code>bx, by</code>の要素をそれぞれ<code>scale</code>倍する</li>
<li><code>nx = c * bx - s * by、ny = s * bx + c*by</code>という変換(回転行列の演算)をして</li>
<li>得られた<code>(nx, ny)</code>というタプルを<code>r</code>に追加し</li>
<li><code>r</code>を返す</li>
</ul>
<p>という処理をしている。リスト内包表記を使うと、<code>for</code>文が消え、かつ「リストにどのような処理を施しているのか」が明確になったのがわかるであろう。しかし、なんでも内包表記を使いすぎると、逆に何をやっているかの手続きがわかりづらくなる場合もある。リスト内包表記を使った方が良いか、素直に<code>for</code>で回した方が良いかは場合によるので、なんでもかんでも内包表記を使おうとせず、どちらが良いか毎回考えながら決めること。</p>
<h2 id="余談名前解決とプログラミング言語の個性">余談：名前解決とプログラミング言語の個性</h2>
<p>プログラムでは、変数や関数、クラスなどに名前をつける。例えば</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> <span class="dv">10</span></code></pre></div>
<p>といった場合、<code>a</code>という変数に<code>10</code>という値が代入されるし、</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> func():
    <span class="bu">print</span>(<span class="st">&quot;Hello&quot;</span>)</code></pre></div>
<p>といった関数<code>func</code>を定義すると、以後<code>func()</code>を実行するたびに「Hello」と表示される。このような「変数名」や「関数名」を識別子と呼ぶ。プログラムをコンパイル、評価した時に、「ある識別子が何を指しているのか？」を決める仕組みを名前解決と呼ぶことは前回学んだ。名前解決は言語処理系の処理の根幹に関わってくるため、言語によって差異が出やすい。</p>
<p>PythonやRubyは値の代入によって変数の宣言を行う言語だが、CやC++、Javaなどの言語は変数の宣言と値の代入は別だ。値の代入が変数宣言を兼ねる場合、それが代入なのか宣言なのかがわかりにくい場合がある。例えば</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> <span class="dv">20</span></code></pre></div>
<p>という文があった場合、これが新たな変数<code>a</code>を宣言しているのか、それとも既存の変数に値が代入されるかは、それまでに<code>a</code>という変数が存在しているかどうかによる。これにより、以下のプログラム</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> <span class="dv">10</span>
<span class="kw">def</span> func():
    <span class="bu">print</span>(a)
func()</code></pre></div>
<p>ではグローバル変数の値が表示されるが、以下のプログラム</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> <span class="dv">10</span>
<span class="kw">def</span> func():
    a <span class="op">=</span> <span class="dv">20</span>
func()</code></pre></div>
<p>では関数<code>func</code>内で新たなローカル変数が作られるため、グローバル変数に影響を与えない。</p>
<p>これがC++の場合は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="dv">10</span>;
<span class="dt">void</span> func(){
   a = <span class="dv">20</span>; <span class="co">// これはグローバル変数を修正する</span>
   <span class="dt">int</span> a = <span class="dv">30</span>; <span class="co">// ここでローカル変数が宣言され、以後`a`はローカル変数となる</span>
}</code></pre></div>
<p>と、変数は宣言しないと利用できないため、<code>a=20</code>が宣言なのか代入なのかわからない、という問題は生じない。</p>
<p>Pythonと同様に代入によって変数を宣言する言語であるRubyは、「グローバル変数には<code>$</code>をつける」という言語デザインにしたため、ローカルスコープにある変数がローカルなのかグローバルなのかわからない、という問題は生じない。他にも、スコープがネストした場合の名前解決の方法等は言語によって違いが大きい。</p>
<p>言語を設計する時、ほとんどの場合は設計と同時にコンパイラなりインタプリタなりといった「言語処理系」が実装される。識別子をどう扱うか、スコープをどうするかはコンパイラやインタプリタの実装に直結するため、名前解決には言語設計者のポリシーの違いが強く出やすい。ある言語で当たり前に受け入れられている方法が、別の言語では禁止されていたり、全く異なる方法で実現されるなど、ある言語の「常識」が別の言語の「非常識」であることも多い。プログラミング言語を一つしか知らないと、このような違いに目がいかず、「自分が知っているプログラミング言語固有の常識」を「プログラミング言語一般の常識」と思ってしまいがちである。</p>
<p>「どの言語の設計が良い」「悪い」ではない。使いこなす必要はないが、複数のプログラミング言語に触れ、広い視野を持つようにしてほしい。プログラミング言語設計の歴史や、言語間の差異については「<a href="https://www.amazon.co.jp/dp/477415654X">コーディングを支える技術 (西尾 泰和)</a>に事例が豊富に掲載されているので参考にされたい。</p>
</article>
</body>
</html>
