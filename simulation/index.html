<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                <title></title>
    <style type="text/css">
      code {
        white-space: pre;
      }
    </style>
        <style type="text/css">
      div.sourceCode {
        overflow-x: auto;
      }

      table.sourceCode,
      tr.sourceCode,
      td.lineNumbers,
      td.sourceCode {
        margin: 0;
        padding: 0;
        vertical-align: baseline;
        border: none;
      }

      table.sourceCode {
        width: 100%;
        line-height: 100%;
      }

      td.lineNumbers {
        text-align: right;
        padding-right: 4px;
        padding-left: 4px;
        color: #aaaaaa;
        border-right: 1px solid #aaaaaa;
      }

      td.sourceCode {
        padding-left: 5px;
      }

      code>span.kw {
        color: #007020;
        font-weight: bold;
      }

      /* Keyword */
      code>span.dt {
        color: #902000;
      }

      /* DataType */
      code>span.dv {
        color: #40a070;
      }

      /* DecVal */
      code>span.bn {
        color: #40a070;
      }

      /* BaseN */
      code>span.fl {
        color: #40a070;
      }

      /* Float */
      code>span.ch {
        color: #4070a0;
      }

      /* Char */
      code>span.st {
        color: #4070a0;
      }

      /* String */
      code>span.co {
        color: #60a0b0;
        font-style: italic;
      }

      /* Comment */
      code>span.ot {
        color: #007020;
      }

      /* Other */
      code>span.al {
        color: #ff0000;
        font-weight: bold;
      }

      /* Alert */
      code>span.fu {
        color: #06287e;
      }

      /* Function */
      code>span.er {
        color: #ff0000;
        font-weight: bold;
      }

      /* Error */
      code>span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      }

      /* Warning */
      code>span.cn {
        color: #880000;
      }

      /* Constant */
      code>span.sc {
        color: #4070a0;
      }

      /* SpecialChar */
      code>span.vs {
        color: #4070a0;
      }

      /* VerbatimString */
      code>span.ss {
        color: #bb6688;
      }

      /* SpecialString */
      code>span.va {
        color: #19177c;
      }

      /* Variable */
      code>span.cf {
        color: #007020;
        font-weight: bold;
      }

      /* ControlFlow */
      code>span.op {
        color: #666666;
      }

      /* Operator */
      code>span.pp {
        color: #bc7a00;
      }

      /* Preprocessor */
      code>span.at {
        color: #7d9029;
      }

      /* Attribute */
      code>span.do {
        color: #ba2121;
        font-style: italic;
      }

      /* Documentation */
      code>span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      }

      /* Annotation */
      code>span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      }

      /* CommentVar */
      code>span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      }

      /* Information */
    </style>

    <style>
      .btn-square {
        display: inline-block;
        padding: 0.5em 0.5em;
        text-decoration: none;
        background: #668ad8;
        color: #FFF;
        border-bottom: solid 4px #626295;
        border-radius: 5px;
      }

      .btn-square:active {
        -webkit-transform: translateY(4px);
        transform: translateY(4px);
        border-bottom: none;
      }

      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      p.caption {
        display: none;
      }

      img {
        width: 100%
      }



      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    <link rel="stylesheet" href="https://kaityo256.github.io/python_zero/github-markdown.css" type="text/css" />

    <meta name="viewport" content="width=device-width, initial-scale=1">

        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
        <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
        <link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
  </head>

  <body>
    <article class="markdown-body">
                        <h1 id="数値シミュレーション">数値シミュレーション</h1>
<p><a href="../index.html">[Up]</a> <a href="https://github.com/kaityo256/python_zero">[Repository]</a></p>
<h2 id="本稿で学ぶこと">本稿で学ぶこと</h2>
<ul>
<li>差分化</li>
<li>弾道計算</li>
<li>反応拡散方程式</li>
</ul>
<h2 id="数値シミュレーションとは">数値シミュレーションとは</h2>
<p>物理学とは、我々が存在するこの宇宙を記述する学問である。そして(なぜかはわからないが)この宇宙は微分方程式で記述されている。したがって、極言すれば物理学とは微分方程式を解く学問である。幸か不幸か、ほとんどの微分方程式は解析的に解くことができない。しかし、方程式さえわかれば、それを数値的に解くことは可能である。何かの現象に着目し、それを記述する方程式を <strong>支配方程式(governing equation)</strong> と呼ぶ。この支配方程式を数値的に解くことでその振る舞いを調べることを <strong>数値シミュレーション(numerical simulation)</strong> と呼ぶ。</p>
<p>さて、この世界の空間や時間は(おそらく)連続的であるのに対し、コンピュータは原則として離散的な値しか扱うことができない。数値シミュレーションとはこの世界の出来事をコンピュータの中に再現することであるから、計算するにあたって連続的な値を離散的な値に変換する必要がある。例えば、パソコンやスマホで動画を見ることがあるだろう。動画は、我々が目にする世界のように、空間的にも時間的にも連続的に見えるが、実際には時間方向は静止画像を高速にコマ送りすることで連続的に見せており、静止画像も拡大するとピクセル単位で離散化されている。</p>
<div class="figure">
<img src="fig/discretization.png" alt="時間と空間の離散化" />
<p class="caption">時間と空間の離散化</p>
</div>
<p>このように、連続的な値をコンピュータで扱うために離散的な値にすることを <strong>離散化(discretization)</strong> と呼ぶ。以下では、時間や空間を離散化することで微分方程式を計算機が扱いやすい形にして、その振る舞いを数値シミュレーションで解析してみよう。</p>
<h2 id="差分化">差分化</h2>
<p>今、ある量<span class="math inline">\(f(t)\)</span>の時間微分<span class="math inline">\(f&#39;(t)\)</span>が与えられているとしよう。時間に関する離散化とは、ある小さな時間刻み<span class="math inline">\(h\)</span>に対して、<span class="math inline">\(f(t)\)</span>の値からなんとかして<span class="math inline">\(f(t+h)\)</span>の値を推定することである。時間微分<span class="math inline">\(f&#39;(t)\)</span>がわかっているので、厳密な表式は積分で与えられる。</p>
<p><span class="math display">\[
f(t+h) = f(t) + \int_t^{t+h} f&#39;(t) dt
\]</span></p>
<p>この式の意味は時刻<span class="math inline">\(t\)</span>において<span class="math inline">\(f(t)\)</span>の値である時、それに<span class="math inline">\(t\)</span>から<span class="math inline">\(t+h\)</span>までの時間変化<span class="math inline">\(f&#39;(t)\)</span>をすべて積算したものを加えると<span class="math inline">\(f(t+h)\)</span>の値になります、ということであり、なんら難しいことは言っていない。</p>
<p>さて、一般にはこの積分を求積することはできないので、なんらかの近似をする。最も単純な近似は、時間刻み<span class="math inline">\(h\)</span>が小さいので、その間は<span class="math inline">\(f&#39;(t)\)</span>が時間変化しないものとみなすことだろう。すると、<span class="math inline">\(f&#39;(t)\)</span>を積分の外に出すことができるので、</p>
<p><span class="math display">\[
f(t+h) \sim f(t) + h f&#39;(t)
\]</span></p>
<p>と近似することができる。<span class="math inline">\(f(t+h)\)</span>を<span class="math inline">\(t\)</span>の周りでテイラー展開して、1次までとると、</p>
<p><span class="math display">\[
\begin{aligned}
f(t + h) &amp;= f(t) + f&#39;(t)h + O(h^2) \\
\end{aligned}
\]</span></p>
<p>となることから、先程の近似は<span class="math inline">\(h\)</span>の1次まで正しい。これを1次近似と呼ぶ。この式は、右辺、すなわち時刻<span class="math inline">\(t\)</span>における<span class="math inline">\(f(t)\)</span>の値と、その微係数<span class="math inline">\(f&#39;(t)\)</span>がわかっていれば、左辺、すなわち時刻<span class="math inline">\(t+h\)</span>における値<span class="math inline">\(f(t+h)\)</span>は、<span class="math inline">\(f(t) + f&#39;(t)h\)</span>で近似できる。</p>
<div class="figure">
<img src="fig/nextstep.png" alt="時間の差分化" />
<p class="caption">時間の差分化</p>
</div>
<p>以上から、ある時刻<span class="math inline">\(t_0\)</span>における値<span class="math inline">\(f(t_0)\)</span>がわかっているとき、</p>
<p><span class="math display">\[
\begin{aligned}
f(t_0+h) &amp;= f(t_0) + f&#39;(t_0)h \\
f(t_0+2h) &amp;= f(t_0+h) + f&#39;(t_0+h)h \\
f(t_0+3h) &amp;= f(t_0+2h) + f&#39;(t_0+2h)h \\
&amp; \cdots 
\end{aligned}
\]</span></p>
<p>と、代入を繰り返すことで任意の時刻の値を求めることができる。このように、微分を離散単位で近似することを差分化と呼び、差分化により微分方程式を扱う手法を <strong>差分法(finite difference method)</strong> と呼ぶ。特に、先程のように1次近似の差分法を <strong>オイラー法 (Euler's method)</strong> と呼ぶ。</p>
<h2 id="ニュートンの運動方程式">ニュートンの運動方程式</h2>
<p>互いに重力で引き合う2つの星の軌道の形が楕円となることは知っているであろう。ではなぜ楕円となるか、答えられるだろうか？　様々な答えはあろうが、一つの答えは「距離の逆2乗に比例する力で互いに引き合う2つの物質の運動方程式を解くと、その軌道が楕円となるから」である。さて、運動方程式とはなんだったか覚えているだろうか。最も簡単な運動方程式は<span class="math inline">\(F=ma\)</span>である。これは、物質にかかる加速度と力が比例し、その比例係数が物質の質量であることを主張する。さて、加速度とは速度の時間変化である。したがって、先ほどの運動方程式は、より正確に書くと</p>
<p><span class="math display">\[
m \frac{d v}{dt} = F
\]</span></p>
<p>となる。さらに速度とは、単位時間当たりの位置の変化分であった。それもあわせて書くと、以下の式が得られる。</p>
<p><span class="math display">\[
\begin{aligned}
\frac{d v}{dt} &amp;= \frac{F}{m} \\
\frac{d r}{dt} &amp;= v
\end{aligned}
\]</span></p>
<p>すなわち、運動方程式とは時間に関する連立常微分方程式である。ここで、2つの物体の間に距離の2乗に反比例する力を仮定すると、宇宙空間内で互いに重力で引き合う2つの星の運動を表す方程式となる。これを解くと、軌道が楕円になることや、面積速度一定則、調和の法則など、いわゆるケプラーの三法則が導かれる。 自然科学において法則とは、実験や観測などで再現可能な自然の振る舞いである。物理学とは、より基本的な原理から、観測事実である「法則」を導き、説明しようとする営みである。以下では、運動方程式の簡単な場合として、重力下での自由運動、すなわち弾道計算を行ってみよう(課題1)。</p>
<h3 id="空気抵抗がない場合の弾道計算">空気抵抗がない場合の弾道計算</h3>
<p>ものを斜め上に投げた時、最も遠くに飛ばすにはどんな角度で投げればよいだろうか。ただし空気抵抗は無視するものとする。答えが初速に依らず45度であることは知っているであろう。では逆に、初速と的までの距離が決まっているときに、何度で投げれば的に当てることができるだろうか？例えば初速100m/sで、500m先にある的に当てたいときの角度は？さらに、投げる場所と当てたい場所に高低差がある場合はどうなるだろう？空気抵抗を無視するなら2次方程式を解くだけだが、すぐに暗算するのは難しいであろう。この「重力下で物に初速を与えて飛ばして目的の場所に落とす」という設定は、戦争において極めて重要な問題設定であった。例えば敵までの距離がわかっているときに、迫撃砲の角度を何度にすればよいかを「すぐに」決めなくてはならない。当然だが戦闘中にいちいち方程式を解く暇はなく、実際には空気抵抗もあるために距離と角度の関係は難しい。そこで、あらかじめ弾の種類と距離の応じて「射表」と呼ばれる距離と角度の関係表を作っていた。実際に射出して着弾距離を調べることも行われたが、数値計算も行われた。最初期の電子計算機であるENIACは、もともと砲撃の射表の作成のために作られたものだ。ENIACは微分方程式を解くことができ、これが本格的な数値シミュレーションの始まりである。ENIACはその後「マンハッタン計画」にも用いられたことからもわかるように、計算機は軍事利用と深い関係にあり、スーパーコンピュータは半ば「兵器」として扱われた。強力な計算機を保有することは軍事的に優位に立つために必要であり、実は現在もその名残が様々なところにみられるのだが、それはさておく。</p>
<p>さて、いま皆さんの目の前にあるのは、ちょっと前のスーパーコンピュータなみの計算能力を持つ計算機である。それを使って、簡単なシミュレーションをしてみよう。2次元の場合を考えよう。速度ベクトルを<span class="math inline">\(\vec{v} = (v_x, v_y)\)</span>、位置ベクトルを<span class="math inline">\(\vec{r} = (r_x, r_y)\)</span>とし、運動方程式をそれぞれの要素について書き下すと以下のようになる。</p>
<p><span class="math display">\[
\begin{aligned}
\dot{v_x} &amp;= 0 \\
\dot{v_y} &amp;= - g \\
\dot{r_x} &amp;= v_x \\
\dot{r_y} &amp;= v_y
\end{aligned}
\]</span></p>
<p>さて、この式は厳密に解けるのだが、その厳密解を知らないものとし、シミュレーションで近似的に解を求めることにする。求めたいものは重力下で角度<span class="math inline">\(\theta\)</span>で物体を投げた時の物体の軌道である。まず、数値計算で扱いやすいように、時間を離散化しよう。</p>
<p>先の運動方程式に1次の差分化(オイラー法)を適用すると、</p>
<p><span class="math display">\[
\begin{aligned}
v_x(t+h) &amp;= v_x(t) \\
v_y(t+h) &amp;= v_y(t) - g h\\
r_x(t+h) &amp;= r_x(t) + v_x(t) h \\
r_y(t+h) &amp;= r_y(t) + v_y(t) h\\
\end{aligned}
\]</span></p>
<p>となる。この計算を一度行うことで、時刻<span class="math inline">\(t\)</span>の物理量から時刻<span class="math inline">\(t+h\)</span>の物理量が得られる。あとはこれを繰り返せば(時間刻み<span class="math inline">\(h\)</span>の精度で)任意の時刻の位置と速度がわかることになる。</p>
<p>厳密解も求めておこう。まず、運動方程式から速度に関する部分を抜き出すと以下のようになる。</p>
<p><span class="math display">\[
\begin{aligned}
\dot{v_x} &amp;= 0 \\
\dot{v_y} &amp;= - g
\end{aligned}
\]</span></p>
<p>これは簡単に求積できる。初期条件として、仰角<span class="math inline">\(\theta\)</span>、速度<span class="math inline">\(v_0\)</span>で投げたとすると、<span class="math inline">\(v_x(0) = v_0 \cos \theta, v_y(0) = v_0 \sin \theta\)</span>であるから、</p>
<p><span class="math display">\[
\begin{aligned}
v_x(t) &amp;= v_0 \cos \theta \\
v_y(t) &amp;= -gt + v_0 \sin \theta
\end{aligned}
\]</span></p>
<p>となる。これをさらに時間積分したものが座標であるから、初期位置が原点、すなわち<span class="math inline">\((r_x, r_y) = (0,0)\)</span> であったとすると、</p>
<p><span class="math display">\[
\begin{aligned}
r_x(t) &amp;= v_0 t \cos \theta \\
r_y(t) &amp;= -\frac{g t^2}{2} + v_0 t \sin \theta
\end{aligned}
\]</span></p>
<p>これが求めたい軌道であった。着弾するまでの時間は<span class="math inline">\(r_y(t_f) = 0\)</span>となる<span class="math inline">\(t_f\)</span>であるから、</p>
<p><span class="math display">\[
t_f = 0, \frac{2 v_0 \sin \theta}{g}
\]</span></p>
<p>である。<span class="math inline">\(x\)</span>方向の速度はずっと<span class="math inline">\(v_0 \cos \theta\)</span>であるから、着弾までに飛んだ水平距離<span class="math inline">\(l(\theta)\)</span>は</p>
<p><span class="math display">\[
l(\theta) = v_0 t_f \cos \theta = \frac{2 v_0^2 \sin \theta \cos \theta}{g}
\]</span></p>
<p>これを最大にする角度は、<span class="math inline">\(l&#39;(\theta)=0\)</span>を満たす<span class="math inline">\(\theta\)</span>であり、<span class="math inline">\(v_0\)</span>や<span class="math inline">\(g\)</span>の値によらず<span class="math inline">\(\theta = \pi/2\)</span>、すなわち45度であることがわかる。</p>
<h3 id="高低差がある場合の弾道計算">高低差がある場合の弾道計算</h3>
<div class="figure">
<img src="fig/throw.png" alt="高低差がある場合の弾道" />
<p class="caption">高低差がある場合の弾道</p>
</div>
<p>さて、先程は、水平な地面から物を投げて、そのまま地面にぶつかるまでの距離を計算した。この場合、最も遠くに飛ぶ角度は45度である。では、台の上に乗って物を投げた場合はどうだろうか？なんとなく一番遠くに飛ぶ角度が45度からずれることは想像がつくであろう。では、上向きにずれるだろうか？それとも下向きにずれるだろうか？</p>
<p>いま、初速<span class="math inline">\(v_0\)</span>、仰角<span class="math inline">\(\theta\)</span>で投げるのは同じとして、最初に高さ<span class="math inline">\(y_0\)</span>から物体を投げたとしよう。物体が従う運動方程式は地面から投げた場合と同じだが、初期条件が異なる。まず、速度については解は変わらない。</p>
<p><span class="math display">\[
\begin{aligned}
v_x(t) &amp;= v_0 \cos \theta \\
v_y(t) &amp;= -gt + v_0 \sin \theta
\end{aligned}
\]</span></p>
<p>しかし、位置については、<span class="math inline">\(r_y\)</span>に<span class="math inline">\(y_0\)</span>が加わる。</p>
<p><span class="math display">\[
\begin{aligned}
r_x(t) &amp;= v_0 t \cos \theta \\
r_y(t) &amp;= -\frac{g t^2}{2} + v_0 t \sin \theta + y_0
\end{aligned}
\]</span></p>
<p>違いはたったこれだけだが、急に式が面倒になる。まず、着弾までの時刻<span class="math inline">\(t_f\)</span>は<span class="math inline">\(r_y(t_f)=0\)</span>の解であるから、</p>
<p><span class="math display">\[
t_f = \frac{v_0 \sin \theta + \sqrt{v_0^2 \sin^2 \theta + 2 g y_0}}{g}
\]</span></p>
<p>ただし、複号は正の解をとった。着弾までに進む水平距離は、</p>
<p><span class="math display">\[
l(\theta) = v_0 t_f \cos\theta
\]</span></p>
<p>これを<span class="math inline">\(\theta\)</span>で微分して<span class="math inline">\(l&#39;(\theta)=0\)</span>となる<span class="math inline">\(\theta\)</span>を探せばよいが、実際に計算すると、解が初等的には求まらないことがわかるであろう。これを数値計算で求めてみよう。</p>
<h2 id="反応拡散方程式グレイスコット模型">反応拡散方程式(グレイ・スコット模型)</h2>
<p>先程はニュートンの運動方程式を数値的に解くことで弾道計算を行った。この時、時間のみ離散化し、空間は連続のままだった。次は時間と同時に空間も離散化してみよう。そんな系の例として <strong>反応拡散系(diffusion-reaction system)</strong> を取り上げる(課題2)。</p>
<p>等モルの塩酸と水酸化ナトリウムを混ぜると、食塩水ができることは知っているであろう。この反応は一方通行であり、混ざって食塩ができておしまいである。しかし、ある種類の化合物を混ぜて反応させると、ある物質ができたり消えたりを繰り返すことがある。最も有名な例はBZ反応(ベロウゾフ・ジャボチンスキー反応, Belousov-Zhabotinsky Reaction)であろう。これは、ある溶液を混ぜると、その後しばらく溶液の色が周期的に変動する現象である。非常に雑に説明すると、反応を記述する方程式が時間の２階微分方程式になり、振動解が出てくるのがこの現象の本質である。</p>
<div class="figure">
<img src="fig/bz.png" alt="BZ反応" />
<p class="caption">BZ反応</p>
</div>
<p>さて、BZ反応は時間的に変動する現象であるが、これが拡散と結びつくと、時間的な変動が空間的に伝播していく。これにより複雑な模様ができあがる。化学反応(reaction)と拡散(diffusion)が組み合わさった現象であるから反応拡散系(diffusion-reaction system)と呼ばれる。反応拡散系は様々な例が知られているが、そのうちの一つ、グレイ・スコットモデル(Gray-Scott model)を取り上げる。</p>
<p>グレイ・スコットモデルは、以下のような連立偏微分方程式で記述される。</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial u}{\partial t} &amp;= D_u \Delta u - uv^2 + F(1-u) \\
\frac{\partial v}{\partial t} &amp;= D_v \Delta v + uv^2 - (F+k)v
\end{aligned}
\]</span></p>
<p>右辺の第1項が拡散項、その後ろにあるのが反応を記述する力学系である。3次元を考えることもできるが、ここでは2次元空間を考える。</p>
<div class="figure">
<img src="fig/gs.png" alt="Gray-Scott模型" />
<p class="caption">Gray-Scott模型</p>
</div>
<p>まず、空間を差分化して扱うことにしよう。本来連続的な空間を、グリッドに分割することで離散的な表現に落とす。</p>
<p><span class="math inline">\(\Delta\)</span>はラプラシアンと呼ばれる2階微分演算子で、2次元なら以下で定義される。</p>
<p><span class="math display">\[
\Delta \equiv \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}
\]</span></p>
<p>今は２次元空間を考えているが、まずは１次元の世界<span class="math inline">\(f(x)\)</span>を考える。微分方程式に２階微分が含まれているので、２階微分を近似したい。そのために、<span class="math inline">\(f(x+h)\)</span>と<span class="math inline">\(f(x-h)\)</span>をそれぞれ２次までテイラー展開してみよう。</p>
<p><span class="math display">\[
\begin{aligned}
f(x + h) &amp;= f(x) + f&#39;(x)h + \frac{h^2}{2} f&#39;&#39;(x) + O(h^3) \\
f(x - h) &amp;= f(x) - f&#39;(x)h + \frac{h^2}{2} f&#39;&#39;(x) + O(h^3)
\end{aligned}
\]</span></p>
<p>両辺足すと<span class="math inline">\(f&#39;(x)\)</span>の項が消えるので、整理して</p>
<p><span class="math display">\[
f&#39;&#39;(x) = \frac{f(x+h) - 2 f(x) + f(x-h)}{h^2}
\]</span></p>
<p>を得る。全く同様にして、2変数関数の2階微分(ラプラシアン)は、以下のように表現できる。</p>
<p><span class="math display">\[
\Delta f(x,y) \sim \frac{f(x+h,y)+f(x-h,y)+f(x,y+h)+f(x,y-h)-4f(x,y)}{h^2}
\]</span></p>
<p>簡単のため、<span class="math inline">\(h=1\)</span>としよう。空間の離散化により<span class="math inline">\(f(m, n)\)</span>の値を2次元配列<code>s[m][n]</code>で表現する。すると、位置<span class="math inline">\((m,n)\)</span>におけるラプラシアンは、この配列<code>s</code>を用いて</p>
<p><code>s[m+1][n] + s[m-1][n] + s[m][n+1] + s[m][n-1] - 4 * s[m][n]</code></p>
<p>と表現できる。これは、前後左右のセルの値の合計から、自分の値の4倍を引いたものであり、自分が「まわりの平均」よりも大きい時に負、小さい時に正となる。このように、ラプラシアンは「なるべくまわりに合わせよう、全体を平均化しよう」という働きをする。</p>
<div class="figure">
<img src="fig/procedure.png" alt="差分計算の流れ" />
<p class="caption">差分計算の流れ</p>
</div>
<p>もともとの式のうち、時間微分は1次の差分を取ることで計算する。その時間発展にはラプラシアンという空間微分が含まれているが、それについては中央差分で近似した。これで数値計算に必要な式がすべて揃った。</p>
<h2 id="数値シミュレーション課題">数値シミュレーション:課題</h2>
<h3 id="課題1運動方程式">課題1:運動方程式</h3>
<p>まずは物を投げた場合の運動を、運動方程式を解くことで数値的に追ってみよう。新しいノートブックを開き、<code>ballistic.ipynb</code>という名前で保存せよ。</p>
<h4 id="ライブラリのインポート">1. ライブラリのインポート</h4>
<p>最初のセルで、必要なライブラリのインポートをしよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">from</span> math <span class="im">import</span> pi, cos, sin
<span class="im">from</span> pylab <span class="im">import</span> rcParams</code></pre></div>
<h4 id="プロットサイズの変更">2. プロットサイズの変更</h4>
<p>デフォルトサイズでは、ややグラフが小さいので、少しサイズを大きくしておこう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">rcParams[<span class="st">&#39;figure.figsize&#39;</span>] <span class="op">=</span> <span class="dv">10</span>, <span class="dv">5</span></code></pre></div>
<h4 id="運動方程式の数値解法">3. 運動方程式の数値解法</h4>
<p>時間方向について差分化した運動方程式を数値的に解くルーチン、<code>throw</code>を実装しよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> throw(theta, y0):
    rx, ry <span class="op">=</span> <span class="fl">0.0</span>, y0
    vx, vy <span class="op">=</span> cos(theta), sin(theta)
    ax, ay <span class="op">=</span> [], []
    g <span class="op">=</span> <span class="fl">1.0</span>
    h <span class="op">=</span> <span class="fl">0.001</span>
    <span class="cf">while</span> ry <span class="op">&gt;=</span> <span class="fl">0.0</span>:
        rx <span class="op">+=</span> vx <span class="op">*</span> h
        ry <span class="op">+=</span> vy <span class="op">*</span> h
        vy <span class="op">-=</span> g <span class="op">*</span> h
        ax.append(rx)
        ay.append(ry)
    <span class="cf">return</span> ax, ay</code></pre></div>
<p>ここで、<code>theta</code>は投げる角度(仰角)、<code>y0</code>は最初に立っている「台」の高さである。</p>
<h4 id="プロット">4. プロット</h4>
<p>投げる角度と台の高さを受け取って、軌道をグラフにする関数<code>plot</code>を実装しよう。比較のため、複数の角度をリストで受け取り、それぞれの角度で投げた場合の軌道を重ねて表示している。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> plot(angles, y0<span class="op">=</span><span class="fl">0.0</span>):
    <span class="cf">for</span> theta <span class="kw">in</span> angles:
        nx, ny <span class="op">=</span> throw(theta <span class="op">/</span> <span class="fl">180.0</span> <span class="op">*</span> pi, y0)
        plt.plot(nx, ny, label<span class="op">=</span>theta)
    plt.legend()
    plt.show()</code></pre></div>
<h4 id="地面から投げた場合">5. 地面から投げた場合</h4>
<p>まず、地面から投げた場合(<code>y0=0</code>の場合)を見てみよう。40度、45度、50度で投げてみた軌道を重ねて表示する。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">angles <span class="op">=</span> [<span class="dv">40</span>, <span class="dv">45</span>, <span class="dv">50</span>]
plot(angles)</code></pre></div>
<p>予想通り、45度がもっとも遠くに届いているだろうか？</p>
<h4 id="台の上から投げた場合">6. 台の上から投げた場合</h4>
<p>次に、台の上から投げてみよう。最初に高さ<span class="math inline">\(1\)</span>の台に乗ってものを投げた場合にどうなるか調べてみる。遠くに届く角度が45度から増えるか減るか、予想してから実行すること。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">angles <span class="op">=</span> [<span class="dv">40</span>, <span class="dv">45</span>, <span class="dv">50</span>]
plot(angles, <span class="fl">1.0</span>)</code></pre></div>
<p>実際に一番遠くに届く角度は45度から増えただろうか、減っただろうか。入力する角度を5度刻みで変化させ、最も遠くに届く角度を調べよ。</p>
<h3 id="発展課題初速依存性">発展課題：初速依存性</h3>
<p>先程の運動方程式では、初速を<span class="math inline">\(1\)</span>に固定していた。関数<code>throw</code>の初速を与える箇所を、以下のように変更すると、初速を<span class="math inline">\(2\)</span>に変えることができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">    vx, vy <span class="op">=</span> <span class="fl">2.0</span><span class="op">*</span>cos(theta), <span class="fl">2.0</span><span class="op">*</span>sin(theta)</code></pre></div>
<p>初速を大きくした場合、「台から投げた時」の「最も遠くに届く角度」は増えるだろうか、減るだろうか？初速を<span class="math inline">\(10\)</span>にしたらどうなるだろう？初速が大きい極限でどうなるか考察せよ。</p>
<h3 id="課題2反応拡散方程式">課題2:反応拡散方程式</h3>
<p>反応拡散方程式を数値的に解いてみよう。新しいノートブックを開き、<code>gs.ipynb</code>という名前で保存せよ。</p>
<h4 id="ライブラリのインポート-1">1. ライブラリのインポート</h4>
<p>最初のセルで、必要なライブラリのインポートをしよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">from</span> numba <span class="im">import</span> jit
<span class="im">from</span> matplotlib <span class="im">import</span> animation, rc</code></pre></div>
<h4 id="ラプラシアンの実装">2. ラプラシアンの実装</h4>
<p>2次元配列<code>s[m][n]</code>の、位置<span class="math inline">\((m,n)\)</span>におけるラプラシアンは、</p>
<p><code>s[m+1][n] + s[m-1][n] + s[m][n+1] + s[m][n-1] - 4 * s[m][n]</code></p>
<p>と表現できる。これを用いて、2次元配列<code>s</code>と位置<code>m,n</code>を受け取って、その位置でのラプラシアンの値を返す関数<code>laplacian</code>を実装したい。以下はそれを途中まで実装したものだ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="at">@jit</span>
<span class="kw">def</span> laplacian(m, n, s):
    ts <span class="op">=</span> <span class="fl">0.0</span>
    ts <span class="op">+=</span> s[m<span class="op">+</span><span class="dv">1</span>][n]
    ts <span class="op">+=</span> s[m<span class="op">-</span><span class="dv">1</span>][n]
    ts <span class="op">+=</span> s[m][n<span class="op">+</span><span class="dv">1</span>]
    ts <span class="op">+=</span> s[m][n<span class="op">-</span><span class="dv">1</span>]
    <span class="co"># ここを埋めよ</span>
    <span class="cf">return</span> ts</code></pre></div>
<p>上記がラプラシアンの値となるように、未完成の部分を完成させよ。</p>
<p>なお、関数定義の前に<code>@jit</code>とあるのは、「この関数をJITコンパイルせよ」という指示(デコレータ)である。JITはJust in Timeの略で、実行時にコードをコンパイルすることでコードの実行を加速する。ここではJIT、デコレータともに詳細には触れない。</p>
<h4 id="ラプラシアンのテスト">3. ラプラシアンのテスト</h4>
<p><code>laplacian</code>を実装したらテストしてみよう。以下はすべて三つ目のセルで実行せよ。</p>
<p>まず、<code>laplacian</code>に食わせるテスト用に、NumPyの2次元配列を作成する。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>,<span class="dv">3</span>)
a</code></pre></div>
<p>実行すると以下のような表示になるはずである。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">array([[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>],
       [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>],
       [<span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>]])</code></pre></div>
<p>さて、中央に着目しよう。中央の値は4であり、1,3,5,7に囲まれている。周りの4つの数字の平均は4であり、中央の値と一致するため、この地点でのラプラシアンの値は0になるはずである。確認してみよう。三つ目のセルを以下のように書き換えよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>,<span class="dv">3</span>)
laplacian(<span class="dv">1</span>,<span class="dv">1</span>,a)</code></pre></div>
<p>これは、<code>a</code>という配列の<code>(1,1)</code>地点におけるラプラシアンの中央差分の値を求めよ、という意味である。実行結果として<code>0.0</code>が返ってくれば正しい。</p>
<p>これだけではテストとして不安なので、値を少しずらしてみよう。三つ目のテスト用セルを以下のように修正して実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>,<span class="dv">3</span>)
a[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span>
a</code></pre></div>
<p>まず、入力するリストが以下のような形になる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">[[<span class="dv">0</span> <span class="dv">0</span> <span class="dv">2</span>]
 [<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>]
 [<span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span>]]</code></pre></div>
<p>4の上が1であったのが0になった。したがって、中央は平均よりも高い値になっているから、ラプラシアンは負になるはずである。実際に計算してみよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.arange(<span class="dv">9</span>).reshape(<span class="dv">3</span>,<span class="dv">3</span>)
a[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span>
laplacian(<span class="dv">1</span>,<span class="dv">1</span>,a)</code></pre></div>
<p>上記の実行結果が<code>-1.0</code>になれば正しく計算されている。</p>
<h4 id="時間発展">4. 時間発展</h4>
<p>2つの配列を受け取り、1ステップだけ時間を進める関数<code>calc</code>を実装しよう。以下を4つ目のセルに入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="at">@jit</span>
<span class="kw">def</span> calc(u, v, u2, v2):
    L, _ <span class="op">=</span> u.shape
    dt <span class="op">=</span> <span class="fl">0.2</span>
    F <span class="op">=</span> <span class="fl">0.04</span>
    k <span class="op">=</span> <span class="fl">0.06075</span>
    Du <span class="op">=</span> <span class="fl">0.1</span>
    Dv <span class="op">=</span> <span class="fl">0.05</span>
    lu <span class="op">=</span> np.zeros((L, L))
    lv <span class="op">=</span> np.zeros((L, L))
    <span class="cf">for</span> ix <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, L<span class="op">-</span><span class="dv">1</span>):
        <span class="cf">for</span> iy <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, L<span class="op">-</span><span class="dv">1</span>):
            lu[ix, iy] <span class="op">=</span> Du <span class="op">*</span> laplacian(ix, iy, u)
            lv[ix, iy] <span class="op">=</span> Dv <span class="op">*</span> laplacian(ix, iy, v)
    cu <span class="op">=</span> <span class="op">-</span>v<span class="op">*</span>v<span class="op">*</span>u <span class="op">+</span> F<span class="op">*</span>(<span class="fl">1.0</span> <span class="op">-</span> u)
    cv <span class="op">=</span> v<span class="op">*</span>v<span class="op">*</span>u <span class="op">-</span> (F<span class="op">+</span>k)<span class="op">*</span>v
    u2[:] <span class="op">=</span> u <span class="op">+</span> (lu<span class="op">+</span>cu) <span class="op">*</span> dt
    v2[:] <span class="op">=</span> v <span class="op">+</span> (lv<span class="op">+</span>cv) <span class="op">*</span> dt</code></pre></div>
<p>最初の<code>@jit</code>デコレータを忘れないこと。なお、関数の冒頭で<code>L, _ = u.shape</code>とあるのは、<code>u.shape</code>が2要素のタプルを返す際、そのうち最初の要素を<code>L</code>で受け取るが、2つ目は使わないことをアンダースコア「<code>_</code>」で表現している。宣言だけしてあとで使わない変数はバグの元なので、あとで使わないことがわかっている変数に対しては積極的に<code>_</code>を使って使わないことを明示するようにしたい。</p>
<h4 id="シミュレーションループ">5. シミュレーションループ</h4>
<p>1ステップ時間を進める関数が書けたら、それを何度も呼び出すことで時間発展をさせよう。また、初期条件として模様の「種」を作る。5つ目のセルに以下を入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="at">@jit</span>
<span class="kw">def</span> simulation(L, loop):
    u <span class="op">=</span> np.zeros((L, L))
    u2 <span class="op">=</span> np.zeros((L, L))
    v <span class="op">=</span> np.zeros((L, L))
    v2 <span class="op">=</span> np.zeros((L, L))
    h <span class="op">=</span> L<span class="op">//</span><span class="dv">2</span>
    u[h<span class="op">-</span><span class="dv">6</span>:h<span class="op">+</span><span class="dv">6</span>, h<span class="op">-</span><span class="dv">6</span>:h<span class="op">+</span><span class="dv">6</span>] <span class="op">=</span> <span class="fl">0.9</span>
    v[h<span class="op">-</span><span class="dv">3</span>:h<span class="op">+</span><span class="dv">3</span>, h<span class="op">-</span><span class="dv">3</span>:h<span class="op">+</span><span class="dv">3</span>] <span class="op">=</span> <span class="fl">0.7</span>
    r <span class="op">=</span> []
    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(loop):
        calc(u, v, u2, v2)
        u, u2, v, v2 <span class="op">=</span> u2, u, v2, v
        <span class="cf">if</span> i <span class="op">%</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span>:
          r.append(v.copy())
    <span class="cf">return</span> r</code></pre></div>
<p>これも、最初の行の<code>@jit</code>を忘れないこと。</p>
<h4 id="シミュレーションの実行">6. シミュレーションの実行</h4>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">imgs <span class="op">=</span> simulation(<span class="dv">64</span>, <span class="dv">10000</span>)
n <span class="op">=</span> <span class="bu">len</span>(imgs)
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):
    im <span class="op">=</span> plt.imshow(imgs[n <span class="op">//</span> <span class="dv">4</span> <span class="op">*</span> i])
    plt.show()</code></pre></div>
<p>ここまで正しく入力されていれば、不思議な模様が4枚現れたはずである。</p>
<h4 id="アニメーション">7. アニメーション</h4>
<p>せっかくシミュレーションしたので、アニメーションを表示させよう。そのための準備をする。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">fig <span class="op">=</span> plt.figure()
im <span class="op">=</span> plt.imshow(imgs[<span class="op">-</span><span class="dv">1</span>])
<span class="kw">def</span> update(i):
    im.set_array(imgs[i])</code></pre></div>
<p>実行後、不思議な模様が出力されるはずである。</p>
<h4 id="アニメーションの表示">8. アニメーションの表示</h4>
<p>ではアニメーションを表示してみよう。以下を実行せよ(少し時間がかかる)。画像の下に操作パネルが出たら、再生ボタン(右向きの三角)を押してみよう。アニメーションが表示されたら成功である。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">rc(<span class="st">&#39;animation&#39;</span>, html<span class="op">=</span><span class="st">&#39;jshtml&#39;</span>)
animation.FuncAnimation(fig, update, interval<span class="op">=</span><span class="dv">50</span>, frames<span class="op">=</span><span class="bu">len</span>(imgs))</code></pre></div>
<h2 id="余談パーソナルスーパーコンピュータ">余談：パーソナルスーパーコンピュータ</h2>
<p>パソコンとは「パーソナルコンピュータ」の略、つまり「個人向け計算機」という意味だ。もともと計算機は貴重品かつ大型であり、組織に一つしかないものだった。それが徐々に小型化し、オフィスに一つ(オフコン)になり、さらに個人で独占して利用できるものになった。パソコンが普及するにつれて、もともと「組織に一つ」しかないような巨大な計算機は「スーパーコンピュータ(スパコン)」と呼ばれ、パソコンと区別されるようになった。スパコンは、安くて一億、高ければ数十、数百億円といったその価格もさることながら、その維持も大変である。計算するのには莫大な電気が必要で、かつ使った電気はすべて熱となるからそれを冷却するシステムも必要である。したがって、本来「パソコン」と「スパコン」は相容れない概念のはずだが、スパコンを個人で所有することでその二つを悪魔合体させ、「パーソナルスーパーコンピュータ」という狂った概念を生み出した人がいる。桑原邦郎氏である。彼は流体力学を専門とする研究者で、親から受け継いだ莫大な財産をすべてスパコンに突っ込んだ。東京大学工学部物理工学科の助手、宇宙科学研究所の助教授を経て、自宅に計算流体力学研究所という研究所を作り、そこにスパコンを購入して運用した。最盛期は七台のスパコンがフル稼働し、電気代だけで月に2000万円かかったという。1980年代後半から1990年代にかけて、計算流体力学を専門とする人はほとんど彼のパーソナルスパコンにお世話になったと思われる。自動車メーカも技術者を派遣していたそうだ。また、米国の諜報機関が「軍事目的に使っているのではないか」と疑ったとのエピソードもある。彼は親から受け継いだ莫大な遺産をすべてスパコンに突っ込み、それを惜しげもなくいろんな人に使わせた。</p>
<p>それから紆余曲折あって、計算流体力学研究所はスパコンを手放し、技術コンサルやパソコンの組み立て、販売をする会社となった。私が大学院に進学した際に与えられたパソコンは、この計算流体力学研究所で購入したAlpha21164のマシンであった。指導教員の「せっかくだから組み立てさせてもらったら？」の言葉に甘え、目黒に行ってアルバイトのお兄さんと一緒に自分の研究に使うマシンを組み立てた。そこに社長である桑原氏が様子を見にやってきた。僕が物工の学生と知ると、興味をもっていろいろ聞いてきた。僕はまさか目の前の社長さんが元物工の助手だったなんて知らなかったので「物工のご出身なんですか？どこの研究室ですか？」と的外れな質問をした。彼はただ笑って何も答えなかったのを思い出す。その時は青二才で何もわからなかった私だが、スパコンを使って研究をするようになった今なら、彼からいろいろ興味深い話が聞けたのではないかと残念に思う。桑原氏は2008年、その豪快な生涯を閉じた。「親の遺産をもっとも有効に学術に活かした」と評されている。</p>
          </article>
  </body>

  </html>