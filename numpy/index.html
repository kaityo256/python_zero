<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                <title></title>
    <style type="text/css">
      code {
        white-space: pre;
      }
    </style>
        <style type="text/css">
      div.sourceCode {
        overflow-x: auto;
      }

      table.sourceCode,
      tr.sourceCode,
      td.lineNumbers,
      td.sourceCode {
        margin: 0;
        padding: 0;
        vertical-align: baseline;
        border: none;
      }

      table.sourceCode {
        width: 100%;
        line-height: 100%;
      }

      td.lineNumbers {
        text-align: right;
        padding-right: 4px;
        padding-left: 4px;
        color: #aaaaaa;
        border-right: 1px solid #aaaaaa;
      }

      td.sourceCode {
        padding-left: 5px;
      }

      code>span.kw {
        color: #007020;
        font-weight: bold;
      }

      /* Keyword */
      code>span.dt {
        color: #902000;
      }

      /* DataType */
      code>span.dv {
        color: #40a070;
      }

      /* DecVal */
      code>span.bn {
        color: #40a070;
      }

      /* BaseN */
      code>span.fl {
        color: #40a070;
      }

      /* Float */
      code>span.ch {
        color: #4070a0;
      }

      /* Char */
      code>span.st {
        color: #4070a0;
      }

      /* String */
      code>span.co {
        color: #60a0b0;
        font-style: italic;
      }

      /* Comment */
      code>span.ot {
        color: #007020;
      }

      /* Other */
      code>span.al {
        color: #ff0000;
        font-weight: bold;
      }

      /* Alert */
      code>span.fu {
        color: #06287e;
      }

      /* Function */
      code>span.er {
        color: #ff0000;
        font-weight: bold;
      }

      /* Error */
      code>span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      }

      /* Warning */
      code>span.cn {
        color: #880000;
      }

      /* Constant */
      code>span.sc {
        color: #4070a0;
      }

      /* SpecialChar */
      code>span.vs {
        color: #4070a0;
      }

      /* VerbatimString */
      code>span.ss {
        color: #bb6688;
      }

      /* SpecialString */
      code>span.va {
        color: #19177c;
      }

      /* Variable */
      code>span.cf {
        color: #007020;
        font-weight: bold;
      }

      /* ControlFlow */
      code>span.op {
        color: #666666;
      }

      /* Operator */
      code>span.pp {
        color: #bc7a00;
      }

      /* Preprocessor */
      code>span.at {
        color: #7d9029;
      }

      /* Attribute */
      code>span.do {
        color: #ba2121;
        font-style: italic;
      }

      /* Documentation */
      code>span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      }

      /* Annotation */
      code>span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      }

      /* CommentVar */
      code>span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      }

      /* Information */
    </style>

    <style>
      .btn-square {
        display: inline-block;
        padding: 0.5em 0.5em;
        text-decoration: none;
        background: #668ad8;
        color: #FFF;
        border-bottom: solid 4px #626295;
        border-radius: 5px;
      }

      .btn-square:active {
        -webkit-transform: translateY(4px);
        transform: translateY(4px);
        border-bottom: none;
      }

      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      p.caption {
        display: none;
      }

      img {
        width: 100%
      }



      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    <link rel="stylesheet" href="https://kaityo256.github.io/python_zero/github-markdown.css" type="text/css" />

    <meta name="viewport" content="width=device-width, initial-scale=1">

        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
        <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
        <link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
  </head>

  <body>
    <article class="markdown-body">
                        <h1 id="numpyとscipyの使い方">NumPyとSciPyの使い方</h1>
<p><a href="../index.html">[Up]</a> <a href="https://github.com/kaityo256/python_zero">[Repository]</a></p>
<h2 id="本講で学ぶこと">本講で学ぶこと</h2>
<ul>
<li>NumPyの使い方</li>
<li>SciPyの使い方</li>
</ul>
<h2 id="ライブラリ">ライブラリ</h2>
<p>スクリプト言語は同時通訳で、コンパイラ言語は事前翻訳である。なんとなく同時通訳で情報を処理するより、事前に全て翻訳しておいた方が実行が早そうな気がするであろう。スクリプト言語よりもコンパイラ言語の方が「同時通訳」というオーバーヘッドがなく、さらにコードの最適化に時間をかけられることもあって、「一般論としては」同じことをするならコンパイラ言語の方が早い。しかし、現実はさほど単純ではない。</p>
<p>一般に、スクリプト言語は豊富な <strong>ライブラリ(library)</strong> を持つ。ライブラリとは、よく使う機能をパッケージ化したものだ。ライブラリを活用することでよく使う機能を自分で開発する必要がなくなり、楽に早くプログラムを組むことができる。ライブラリは、その言語そのもので書かれたものもあるが、時間がかかる処理についてはCやFortranなどの言語で記述され、事前にコンパイルされている。特に数値計算ライブラリは高度に最適化されていることが多く、よほどのことがなければ自分で直接書くよりPythonからライブラリを呼び出した方が高速に実行できる。本書で扱うNumPyはそのような強力なライブラリの一つだ。</p>
<h2 id="numpyとscipy">NumPyとSciPy</h2>
<p>Pythonには強力なライブラリが多数存在し、それらを使いこなすことで、少ない記述で豊富な機能を素早く実装することができる。今回は、数多くのライブラリの中でも、数値計算、特に行列演算を効率的に行うことができるNumPyと、それを用いて様々な科学的な計算を行うことができるライブラリ、SciPyを使ってみる。</p>
<p>なお、NumPyやSciPyの使い方を覚える必要はない。ただ「PythonにはNumPyやSciPyというライブラリがあり、数行書くだけで行列の固有値問題を解くことができる」ということをぼんやり覚えておいて、将来、必要になった時にそれを思い出して、詳細については本を読むなりウェブで検索するなりすればよい。</p>
<h2 id="numpyの使い方">NumPyの使い方</h2>
<h3 id="numpyとは">NumPyとは</h3>
<p>数値計算では、行列を扱うことが非常に多い。行列がからむ演算の中で特に重要なのが、行列同士の積の計算だ。行列と行列の積を行列行列積と呼ぶ。スーパーコンピュータにはTop500という性能ランキングがあり、年に2回ランキングが更新されるが、そこで行われているベンチマークは巨大な連立1次方程式をどれだけ効率的に解くことができるか、という問題である。そして、その計算の中心は行列行列積である。従って、Top500における「スパコンの性能」は、「いかに行列同士の積を早く計算できるか」に依存している。</p>
<p>行列の積の定義そのものは簡単だ。普通にかけば三重ループで計算できる。しかし、現代の計算機では行列の乗算の効率的な実装は非常に面倒であり、「普通」に書くとまったく性能がでない。なにしろ行列行列積は数値計算の根幹をなす演算であり、そこが遅いと非常に広範囲の計算が影響を受けてしまう。そこで、Pythonにおいて行列を効率的に扱うためのライブラリが作られた。それがNumPyである。</p>
<h3 id="numpy配列の作り方">NumPy配列の作り方</h3>
<p>NumPyを使うには、まず<code>numpy</code>をインポートする。<code>np</code>という別名をつけるのが慣習である。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np</code></pre></div>
<p>NumPy用の配列(NumPy配列)を作成するにはいくつか方法があるが、簡単なのは<code>np.array</code>にリストを与えることだ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">data <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])
<span class="bu">print</span>(data)</code></pre></div>
<pre class="txt"><code>[1 2 3]</code></pre>
<p>以下は二行二列の行列を作る例である。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>]])
<span class="bu">print</span>(a)</code></pre></div>
<pre class="txt"><code>[[1 2]
 [3 4]]</code></pre>
<p>要素が全てゼロの配列を作るには、<code>zeros</code>を使えばよい。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">np.zeros((<span class="dv">2</span>,<span class="dv">2</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">z <span class="op">=</span> np.zeros((<span class="dv">2</span>,<span class="dv">2</span>))
<span class="bu">print</span>(z)</code></pre></div>
<pre class="txt"><code>[[0. 0.]
 [0. 0.]]</code></pre>
<p>NumPy配列のデータには「型」がある。Pythonのリストは複数の型の混在が許されたが、NumPy配列は全て同じ型でなければならない。NumPy配列のデータの型は<code>dtype</code>で調べることができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="bu">print</span>(a.dtype) <span class="co"># =&gt; int64</span>
<span class="bu">print</span>(z.dtype) <span class="co"># =&gt; float64</span></code></pre></div>
<p><code>np.array</code>で作った場合は、与えたリストから推定された型が使われるが、<code>np.zeros</code>の場合はデフォルトで<code>float64</code>の型になる。明示的に型を指定すれば、その型のゼロ要素行列を得ることができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">z2 <span class="op">=</span> np.zeros((<span class="dv">2</span>,<span class="dv">2</span>),dtype<span class="op">=</span>np.int64)
<span class="bu">print</span>(z2.dtype) <span class="co"># =&gt; int64</span></code></pre></div>
<h3 id="numpy配列同士の演算">NumPy配列同士の演算</h3>
<p>NumPy配列は、「形」を保持しており、<code>shape</code>でその形を知ることができる。<code>shape</code>は、タプルの形で返ってくる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">data.shape <span class="co"># =&gt; (2,2)</span></code></pre></div>
<p>形が同じ行列同士は四則演算ができる。ここで<code>*</code>を計算すると、行列積ではなく、「要素ごとの積」を計算することに注意。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">b <span class="op">=</span> np.array([[<span class="dv">5</span>,<span class="dv">6</span>],[<span class="dv">7</span>,<span class="dv">8</span>]])
<span class="bu">print</span>(a<span class="op">*</span>b)</code></pre></div>
<pre class="txt"><code>[[ 5 12]
 [21 32]]</code></pre>
<p>行列行列積を計算したい時には<code>dot</code>を用いる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">c <span class="op">=</span> a.dot(b)
<span class="bu">print</span>(c)</code></pre></div>
<pre class="txt"><code>[[19 22]
 [43 50]]</code></pre>
<h3 id="numpy配列の中身">NumPy配列の中身</h3>
<p>NumPy配列は、どのような「形」でも作ることができる。通常の行列は「行」と「列」のある2次元のデータだが、3次元でも4次元でも作ることができる。しかし、NumPy配列は、実はどのような形であろうとも1次元配列として保存されている。NumPy配列は、1次元のデータ<code>shape</code>プロパティによってどのような形として解釈するかを決めている。<code>reshape</code>を使うことで、データを変更せずに「形」を変えることができる。</p>
<p>連番の要素を持つ1次元のNumPy配列を作るには、<code>arange</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.arange(<span class="dv">8</span>)
<span class="bu">print</span>(a)</code></pre></div>
<pre class="txt"><code>array([0, 1, 2, 3, 4, 5, 6, 7])</code></pre>
<p>このデータを「4行2列の行列」として解釈したNumPy配列を得るには、以下のようにすれば良い。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">b <span class="op">=</span> a.reshape((<span class="dv">4</span>,<span class="dv">2</span>))
<span class="bu">print</span>(b)</code></pre></div>
<pre class="txt"><code>[[0 1]
 [2 3]
 [4 5]
 [6 7]]</code></pre>
<p><code>reshape</code>にはタプルを渡す。総データ数さえ等しければどのような形にもできる。例えば<code>(2,2,2)</code>という形にもできる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">c <span class="op">=</span> a.reshape((<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>))
<span class="bu">print</span>(c)</code></pre></div>
<pre class="txt"><code>[[[0 1]
  [2 3]]

 [[4 5]
  [6 7]]]</code></pre>
<p><code>reshape</code>は、データ数が合わないとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a.reshape((<span class="dv">4</span>,<span class="dv">4</span>)) <span class="co"># =&gt; ValueError: cannot reshape array of size 8 into shape (4,4)</span></code></pre></div>
<h2 id="scipy">SciPy</h2>
<p>SciPyは、NumPyを基礎にした科学計算ライブラリだ。非常に多くのことができるが、それゆえにその全てを説明することはできない。ここでは、行列の固有値と固有ベクトルだけ求めてみよう。</p>
<p>固有値や固有ベクトルを求めるには<code>scipy.linalg</code>をインポートすればよい。多くの場合、一緒に<code>numpy</code>もインポートするであろう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">from</span> scipy <span class="im">import</span> linalg
<span class="im">import</span> numpy <span class="im">as</span> np</code></pre></div>
<p>固有値、固有ベクトルは、<code>linalg.eig</code>で求めることができる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">a <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">1</span>]])
w, v <span class="op">=</span> linalg.eig(a)</code></pre></div>
<p>これで、<code>w</code>に固有値が、<code>v</code>に固有ベクトルがそれぞれリストの形で返ってくる。</p>
<p>例えば固有値は</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="bu">print</span>(w) <span class="co"># =&gt; [ 3.+0.j -1.+0.j]</span></code></pre></div>
<p>つまり「3」と「-1」である。一般に固有値は複素数となるが、今回のように入力が実対称行列(もしくはエルミート行列)であることがわかっていれば、エルミート行列向けの<code>eigh</code>が使える。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">w, v <span class="op">=</span> linalg.eigh(a)
<span class="bu">print</span>(w) <span class="co"># =&gt; [-1.  3.]</span></code></pre></div>
<p>エルミート行列の固有値は常に実数であるから、返り値も実数となる。</p>
<h2 id="シュレーディンガー方程式">シュレーディンガー方程式</h2>
<h3 id="トンネル効果">トンネル効果</h3>
<p>原子スケールのようなミクロの世界では、我々が普段目にする世界とは異なり、不思議なことがおきる。そのうちの一つ、「シュレーディンガーの猫」などは聞いたことがあるだろう。今回は量子力学における不思議の一つ、「トンネル効果」をNumPyを使って計算してみよう(課題1)。</p>
<div class="figure">
<img src="fig/tunneling.png" alt="トンネル効果" />
<p class="caption">トンネル効果</p>
</div>
<p>真っ直ぐな道の真ん中に、小さな山があるとしよう。山の高さを<span class="math inline">\(h\)</span>とする。山の麓にボールを置いて、それに初速を与えて山の方に動かす。初速が、ある程度大きい時には山を超えることができるが、それより小さい場合は山を登りきれずに帰ってくることが予想される。摩擦や回転などを無視して、重力加速度を<span class="math inline">\(g\)</span>、物体の質量を<span class="math inline">\(m\)</span>としよう。初速<span class="math inline">\(v\)</span>を与えると、物体は運動エネルギー<span class="math inline">\(mv^2/2\)</span>を得る。山の頂上に行くためには、ポテンシャルエネルギー<span class="math inline">\(mgh\)</span>が必要だ。以上から、山を登り切るためには<span class="math inline">\(mv^2/2 &gt; mgh\)</span>だけのエネルギーが必要であるため、<span class="math inline">\(v &lt; \sqrt{2gh}\)</span>の時には山を登り切ることができない。このように、量子力学が必要ないようなマクロな世界を古典系と呼ぶ。古典系では、初速が足りなければなんどトライしても山を超えることはできない。</p>
<p>しかし、物体の波動性が効いてくるようなミクロな領域では古典系とは異なることがおきる。初期エネルギーが山を超えるのに必要なエネルギーより小さい場合でも、低確率で山をすり抜けて向こう側に行ってしまう。まるでトンネルを抜けたかのように見えるので、トンネル効果と呼ばれる。トンネル効果は、例えば走査型トンネル顕微鏡などに応用されている。</p>
<h3 id="シュレーディンガー方程式-1">シュレーディンガー方程式</h3>
<p>さて、マクロな物体の運動はニュートンの運動方程式で記述されるが、ミクロな現象は量子力学に支配されている。例えば電子の位置などはシュレーディンガー方程式に従う。時間非依存・1体・1次元のシュレーディンガー方程式は以下のように書ける。</p>
<p><span class="math display">\[
\left(
\frac{-\hbar^2}{2m} \frac{d^2 }{d x^2} + V(x)
\right) \psi(x) = E \psi(x)
\]</span></p>
<p>ここで、<span class="math inline">\(\hbar\)</span>はプランク定数、<span class="math inline">\(m\)</span>は質量である。<span class="math inline">\(V(x)\)</span>はポテンシャルで、位置<span class="math inline">\(x\)</span>による「高さ」を表しており、例えば先程の山の高度だと思えば良い。この方程式を解くことで波動関数<span class="math inline">\(\psi(x)\)</span>を求めることができる。波動関数は、その二乗が「その位置に粒子(例えば電子)を見出す確率」となる。したがって、シュレーディンガー方程式を解くとは、どの場所にどれくらいの確率で粒子が存在するかの確率を求めることに対応する。以下、簡単のため、<span class="math inline">\(\hbar^2/2m\)</span>を<span class="math inline">\(1\)</span>とする単位系をとる。</p>
<p>さて、この方程式を計算機で解くために離散化する。微分方程式の離散化は後の回に説明するので、以下はざっと読み飛ばして良い。先程の式には<span class="math inline">\(x\)</span>に関する二階微分があったが、これを</p>
<p><span class="math display">\[
\frac{d^2 \psi}{d x^2} \sim \frac{\psi(x+h) - 2 \psi(x) + \psi(x-h) }{h^2}
\]</span></p>
<p>と近似する。離散化により、波動関数<span class="math inline">\(\psi(x)\)</span>は、ベクトル<span class="math inline">\(\vec{v}\)</span>で表すことができる。<span class="math inline">\(h\)</span>を1とし、<span class="math inline">\(\vec{v}\)</span>のi番目の成分を<span class="math inline">\(v_i\)</span>とすると、上記の微分は</p>
<p><span class="math display">\[
\frac{d^2 \psi}{d x^2} \sim v_{i+1} - 2 v_i + v_{i-1}
\]</span></p>
<p>と表現できる。右辺は配列の要素の加減算なのでプログラムするのは簡単だ。これを先程の微分方程式に代入すると、最終的に</p>
<p><span class="math display">\[
-v_{i+1} + 2 v_i - v_{i-1} + V_i v_i = E v_i
\]</span></p>
<p>という式が得られる。ただし、<span class="math inline">\(V_i\)</span>は<span class="math inline">\(V(x)\)</span>を離散化してベクトルにした時の<span class="math inline">\(i\)</span>番目の要素だ。これを行列とベクトルで書き表すと、</p>
<p><span class="math display">\[
H \vec{v} = E \vec{v}
\]</span></p>
<p>という、行列の固有値問題になった。ただし<span class="math inline">\(H\)</span>は以下のような要素を持つ行列である。</p>
<div class="figure">
<img src="fig/h_matrix.png" alt="Hの行列要素" />
<p class="caption">Hの行列要素</p>
</div>
<p>長々と書いたが、この式を理解する必要はない。要するに「ミクロな世界はシュレーディンガー方程式で記述され、シュレーディンガー方程式は離散化により行列の固有値問題になる」ということがわかればよい。行列の固有値問題を解くことで、任意のポテンシャル形状<span class="math inline">\(V(x)\)</span>で、電子がどのように分布するかを計算することができる。課題では井戸型ポテンシャルに閉じ込められた電子の存在確率を計算することで、トンネル効果を見てみよう。</p>
<h2 id="特異値分解による画像圧縮">特異値分解による画像圧縮</h2>
<p>線形代数を学んでいれば、異なる行列の積を定義できることを覚えているだろう。例えばm行n列の行列と、n行k列の行列の積をとると、新たにできる行列はm行k列となる。</p>
<div class="figure">
<img src="fig/mprod.png" alt="行列積の定義" />
<p class="caption">行列積の定義</p>
</div>
<p><code>(m,n)</code>の形をした行列と<code>(n,k)</code>の形をした行列から<code>(m,k)</code>の形をした行列ができるのだから、例えば10行2列の行列<span class="math inline">\(A\)</span>と、2行10列の行列<span class="math inline">\(B\)</span>の積は、10行10列の行列<span class="math inline">\(C\)</span>になる。この時、<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>の要素数はそれぞれ20個、合計40個だが、積をとってできる行列<span class="math inline">\(C\)</span>の要素数は100個となり、<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>の要素数の合計よりも多い。この事実を利用して、<span class="math inline">\(C\)</span>という大きな行列を、<span class="math inline">\(A\)</span>と<span class="math inline">\(B\)</span>という「細長い」行列の積で近似することを考えよう。</p>
<div class="figure">
<img src="fig/approximation.png" alt="行列の近似" />
<p class="caption">行列の近似</p>
</div>
<p>つまり、何か行列<span class="math inline">\(X\)</span>が与えられた時、<span class="math inline">\(\tilde{X} = AB\)</span>という行列を作り、<span class="math inline">\(\tilde{X}\)</span>が元の行列<span class="math inline">\(X\)</span>をよく近似するように、なるべく「細長い」行列<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>を探しなさい、という問題である。このような行列は、特異値分解(Singular Value Deconposition, SVD)という方法で作ることができる。</p>
<div class="figure">
<img src="fig/svd.png" alt="特異値分解" />
<p class="caption">特異値分解</p>
</div>
<p>いま、<span class="math inline">\(X\)</span>というm行n列の行列が与えられた時、以下のように「分解」ができる。</p>
<p><span class="math display">\[
X = U \Sigma V^{\dagger}
\]</span></p>
<p>ただし、<span class="math inline">\(U\)</span>はm行m列、<span class="math inline">\(V^{\dagger}\)</span>はn行n列のそれぞれ正方行列であり、<span class="math inline">\(\Sigma\)</span>は対角行列である。この<span class="math inline">\(\Sigma\)</span>の対角成分を特異値と呼び、全て非負の実数に取ることができる。</p>
<p>さて、真ん中の<span class="math inline">\(\Sigma\)</span>を2つの<span class="math inline">\(\sqrt{\Sigma}\)</span>にわけて、それぞれ左右にくっつけると、<span class="math inline">\(X = A B\)</span>の形に書くことができる。この<span class="math inline">\(A\)</span>の行列の「右端の帯」と、<span class="math inline">\(B\)</span>の行列の「上端の帯」の積をとってできる行列<span class="math inline">\(\tilde{X}\)</span>は、元の行列<span class="math inline">\(X\)</span>と同じ形であり、かつ良い近似になっている。これを「行列の低ランク近似」と呼ぶが、ここではその詳細は触れない。</p>
<p>課題では、行列の特異値分解と低ランク近似を利用して、画像圧縮をしてみよう(課題2)。</p>
<h2 id="numpyとscipyの使い方課題">NumPyとSciPyの使い方：課題</h2>
<h3 id="課題1シュレーディンガー方程式">課題1：シュレーディンガー方程式</h3>
<p>シュレーディンガー方程式を離散化することで数値的に解いてみよう。新しいノートブックを開き、<code>tunneling.ipynb</code>という名前で保存せよ。</p>
<h4 id="ライブラリのインポート">1. ライブラリのインポート</h4>
<p>最初のセルはいつもどおりライブラリのインポートである。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">from</span> scipy <span class="im">import</span> linalg
<span class="im">import</span> numpy <span class="im">as</span> np</code></pre></div>
<h4 id="行列の作成">2. 行列の作成</h4>
<p>次に、ポテンシャル<span class="math inline">\(V(x)\)</span>に対応するベクトル<code>V</code>と、微分方程式を差分化した行列<code>H</code>を作成する。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">N <span class="op">=</span> <span class="dv">32</span>
V <span class="op">=</span> np.zeros(N)
V[N <span class="op">//</span> <span class="dv">4</span>:<span class="dv">3</span> <span class="op">*</span> N <span class="op">//</span> <span class="dv">4</span>] <span class="op">=</span> <span class="op">-</span><span class="fl">5.0</span>
H <span class="op">=</span> np.zeros((N, N))
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):
    i1 <span class="op">=</span> (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> N
    i2 <span class="op">=</span> (i <span class="op">-</span> <span class="dv">1</span> <span class="op">+</span> N) <span class="op">%</span> N
    H[i][i] <span class="op">=</span> <span class="fl">2.0</span> <span class="op">+</span> V[i]
    H[i][i1] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>
    H[i][i2] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></code></pre></div>
<h4 id="固有値と最低固有エネルギー">3. 固有値と最低固有エネルギー</h4>
<p>得られた行列の固有値、固有ベクトルを求め、さらに固有値の中でもっとも値が小さいもののインデックスを求めよう。3つ目のセルに以下を入力、実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">w, v <span class="op">=</span> linalg.eigh(H)
i0 <span class="op">=</span> np.argmin(w)
<span class="bu">print</span>(w[i0])</code></pre></div>
<p>最小値を求めるだけなら<code>np.min(w)</code>で良いが、後で対応する固有ベクトルを使うのにインデックスが必要なので、<code>np.argmin(w)</code>を利用している。</p>
<p>実行してみると、-5よりも若干大きな値が表示されたはずである。これが「閉じ込めエネルギー」と呼ばれるものだ。なぜ「閉じ込め」と呼ばれるかは次のステップで可視化することで明らかとなる。</p>
<h4 id="波動関数の可視化">4. 波動関数の可視化</h4>
<p>井戸型ポテンシャルに閉じ込められた波動関数の可視化をしてみよう。波動関数は、その二乗が電子の「存在確率」を表す。先ほど得た「最低固有エネルギー」に対応する固有ベクトルを二乗したものを、ポテンシャルと一緒にプロットしてみよう。4つ目のセルに以下を入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">v <span class="op">=</span> v[:, i0]
v <span class="op">=</span> v <span class="op">*</span> v
plt.plot(v <span class="op">*</span> <span class="dv">20</span> <span class="op">+</span> w[i0])
plt.plot(V)</code></pre></div>
<p>波動関数とポテンシャルが同時にプロットされたはずである。波動関数は「そこに電子が存在する確率」である。その存在確率が少しだけ井戸の外にしみだしていることがわかるはずである。これが「トンネル効果」と呼ばれるものだ。</p>
<h3 id="課題2行列の低ランク近似による画像処理">課題2：行列の低ランク近似による画像処理</h3>
<p>特異値分解による行列の近似を利用して、画像圧縮をしてみよう。高さhピクセル、幅wピクセルのモノクロ画像は、それぞれのピクセルの値を要素だとおもえば、h行w列の行列と思うことができる。それを特異値分解し、「細長い」二つの行列に分離することでデータを圧縮する。「細長い行列」の行列積をとると元の大きさに戻るので、それを可視化することで復元された画像を得ることができる。</p>
<p>新しいノートブックを開き、<code>svd.ipynb</code>という名前で保存せよ。</p>
<h4 id="ライブラリのインポート-1">1. ライブラリのインポート</h4>
<p>1つ目のセルにで、必要なライブラリをインポートしよう。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> urllib.request
<span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> scipy <span class="im">import</span> linalg
<span class="im">from</span> io <span class="im">import</span> BytesIO</code></pre></div>
<h4 id="画像のダウンロード関数">2. 画像のダウンロード関数</h4>
<p>圧縮する元の画像をダウンロードする関数を実装しよう。2つ目のセルで以下を実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> download(url):
    <span class="cf">with</span> urllib.request.urlopen(url) <span class="im">as</span> f:
        data <span class="op">=</span> f.read()
        <span class="cf">return</span> Image.<span class="bu">open</span>(BytesIO(data))</code></pre></div>
<h4 id="画像の表示">3. 画像の表示</h4>
<p>ダウンロード関数のテストをしよう。3つ目のセルで以下を実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">URL <span class="op">=</span> <span class="st">&quot;https://kaityo256.github.io/python_zero/numpy/stop.jpg&quot;</span>
download(URL)</code></pre></div>
<p>カラー画像が表示されれば成功である。</p>
<h4 id="モノクロへの変換">4. モノクロへの変換</h4>
<p>先ほどダウンロードした画像はカラー画像であり、各ピクセルにR、G、Bの値が紐づけられている。このままでは行列とみなすことができないので、モノクロ化する関数を実装しよう。4つ目のセルに以下を実装せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> mono(url):
    img <span class="op">=</span> download(url)
    gray_img <span class="op">=</span> img.convert(<span class="st">&#39;L&#39;</span>)
    <span class="cf">return</span> gray_img</code></pre></div>
<h4 id="モノクロ変換のテスト">5. モノクロ変換のテスト</h4>
<p>モノクロに変換できるか確認しよう。5つ目のセルで以下を実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">URL <span class="op">=</span> <span class="st">&quot;https://kaityo256.github.io/python_zero/numpy/stop.jpg&quot;</span>
mono(URL)</code></pre></div>
<p>モノクロ画像が表示されれば成功である。</p>
<h4 id="画像の低ランク近似">6. 画像の低ランク近似</h4>
<p>画像を特異値分解により低ランク近似する関数を実装しよう。6つ目のセルに以下を入力せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="kw">def</span> svd(url, ratio):
    gray_img <span class="op">=</span> mono(url)
    a <span class="op">=</span> np.asarray(gray_img)
    w, _ <span class="op">=</span> a.shape
    rank <span class="op">=</span> <span class="bu">int</span>(w <span class="op">*</span> ratio)
    u, s, v <span class="op">=</span> linalg.svd(a)
    ur <span class="op">=</span> u[:, :rank]
    sr <span class="op">=</span> np.diag(s[:rank])
    vr <span class="op">=</span> v[:rank, :]
    b <span class="op">=</span> ur <span class="op">@</span> sr <span class="op">@</span> vr
    <span class="cf">return</span> Image.fromarray(np.uint8(b))</code></pre></div>
<p>画像データを<code>asarray</code>に渡すことでそのままNumPy配列にすることができる。その配列を<code>linalg.svd</code>に渡せば特異値分解完了である。その後、<code>ratio</code>で指定された特異値の数だけ残して画像を再構成している。</p>
<h4 id="画像の低ランク近似の確認">7. 画像の低ランク近似の確認</h4>
<p>先程実装した低ランク近似関数を確認しよう。7つ目のセルで以下を実行せよ。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">URL <span class="op">=</span> <span class="st">&quot;https://kaityo256.github.io/python_zero/numpy/stop.jpg&quot;</span>
ratio <span class="op">=</span> <span class="fl">0.1</span>
svd(URL, ratio)</code></pre></div>
<p>上記を実行すると、画像のピクセル値を行列要素だと思って、行列を特異値分解により低ランク近似してから再構成した画像が表示される。<code>ratio</code>は、使う情報の割合であり、その数字を増やすとたくさん情報を使うので近似精度が高くなり、減らすと低くなる。<code>ratio = 0.05</code>の場合と、<code>ratio = 0.2</code>の場合も確認し、画像がどうなるか確認せよ。</p>
<h3 id="発展課題">発展課題</h3>
<p>インターネットで適当な画像を探し、上記の手続きで低ランク近似をせよ。適当な画像で右クリックし、「画像アドレスをコピー」等でアドレスを取得できる。そのアドレスを<code>URL</code>に指定せよ。画像フォーマットはJPG形式とし、あまり大きな画像でない方がよい。また、文字を含む画像である方が圧縮の精度がわかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python">URL <span class="op">=</span> <span class="co"># ここを指定せよ</span>
ratio <span class="op">=</span> <span class="fl">0.1</span>
svd(URL, ratio)</code></pre></div>
<p>いくつかの<code>ratio</code>の値を試してみて、画像の「近似のしやすさ」「再現性が良いところ、悪いところ」等について気づいたことがあれば記述せよ。また、圧縮画像に「黒い斑点」のようなものが現れる場合があるのはなぜか、考察せよ。</p>
<h2 id="余談人外">余談：人外</h2>
<p>「人外」という言葉がある。「じんがい」と読む。主にファンタジーなどの世界において、獣人や精霊、妖精など、人としての外見を持つが、基本的に人よりも高次の存在を「人外」と呼ぶことが多い。世界観にもよるが、基本的に「人外」は人間より優れた能力を持ち、通常の人間が敵う相手ではない、強大な存在として描かれることが多い。いつの頃からか、この「人外」という言葉が「同じ人間とは思えないような、卓越した成果を挙げている人間」を指すようになった。筆者は「同じ人とは思えないプログラム能力を持つ存在」という意味で使っている。この意味での用例の初出がどこかはわからない。おそらく「競技プログラム」界隈から言われるようになったのではないかと思われる。</p>
<p>本稿の読者は大学生を想定しているが、20年近く生きていれば、「あ、こいつには絶対にかなわない」というような、才能の差を感じて絶望したことが一度や二度はあるであろう。おそらく君たちの二倍以上生きている筆者も、自慢じゃないがこれまでなんども「才能の差」に絶望してきた。特に「プログラミング」は、「できる人」と「できない人」の差が極めて大きく開く分野である。定義にもよるが、「できる人」と「できない人」の生産性はかるく桁で変わってしまう。そして、「この人、本当に人間なんかいな」という「人外プログラマ」の作るものを目の当たりにして驚嘆し、自分と比較して絶望し、その後に達観するのである。</p>
<p>我々一般人は、普通に生きていれば「人外」とぶつかる可能性は低い。むしろぶつからないように生きるのが正しい道である。しかし、何かとちくるって、一般人であるにもかかわらず「世界一になりたい」という野望を抱いてしまうと不幸である。なんでもよいが、何かの処理の最速、世界一を目指すと、極めて高確率で「人外」とぶつかる。人外は、その絶対数が少ない希少種である。しかし、何か数値化され、「世界一」が客観的に定義できる場所には(それがどんなにマイナーな分野であっても)必ず生息している。世界一になるためには、彼らに勝たなければいけない。ファンタジーでの定番、圧倒的な存在である人外をどうやって人間が討伐するか、という問題図式である。</p>
<p>ではどうすればいいのか？　まだどの分野でも世界一になったことがない僕は、もちろんその答えを持っていない。</p>
          </article>
  </body>

  </html>